<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>摆人日寄</title>
    <link>https://shenyiminghfut.github.io/</link>
    <description>Recent content on 摆人日寄</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-hant</language>
    <copyright>This is a customized copyright.</copyright>
    <lastBuildDate>Thu, 01 Dec 2022 11:25:05 -0400</lastBuildDate>
    
        <atom:link href="https://shenyiminghfut.github.io/index.xml" rel="self" type="application/rss+xml" />
    
    
    
        <item>
        <title>命令行Clash指南</title>
        <link>https://shenyiminghfut.github.io/posts/%E5%9C%A8-linux-%E4%B8%8A%E4%BD%BF%E7%94%A8-clash-%E4%BD%9C%E4%BB%A3%E7%90%86-verne-in-github/</link>
        <pubDate>Mon, 29 Mar 2021 10:58:08 -0400</pubDate>
        
        <guid>https://shenyiminghfut.github.io/posts/%E5%9C%A8-linux-%E4%B8%8A%E4%BD%BF%E7%94%A8-clash-%E4%BD%9C%E4%BB%A3%E7%90%86-verne-in-github/</guid>
        <description>摆人日寄 https://shenyiminghfut.github.io/posts/%E5%9C%A8-linux-%E4%B8%8A%E4%BD%BF%E7%94%A8-clash-%E4%BD%9C%E4%BB%A3%E7%90%86-verne-in-github/ -&lt;blockquote&gt;
&lt;p&gt;去年年中的时候切换到 macOS，一直用 ClashX，时隔半年又迁移回了 Linux，发现原先使用的 V2rayL 虽然能用，但是有些简陋，并且不支持分流，并且如果一个地址失效了，还需要手动地进行切换。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;去年年中的时候切换到 macOS，一直用 ClashX，时隔半年又迁移回了 Linux，发现原先使用的 V2rayL 虽然能用，但是有些简陋，并且不支持分流，并且如果一个地址失效了，还需要手动地进行切换。所以看到 Linux 的 Clash 可以自动进行流量切换的时候，就试一下。&lt;/p&gt;
&lt;p&gt;Clash 是 Go 语言实现的，跨平台代理工具，支持 Shadowsocks/v2ray，支持规则分流等等。&lt;/p&gt;
&lt;p&gt;可以在官方页面&lt;a href=&#34;https://github.com/Dreamacro/clash/releases&#34;&gt;下载&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;Linux 下载对应的 &lt;code&gt;linux-amd64&lt;/code&gt; 即可。&lt;/p&gt;
&lt;p&gt;在用了很长一段时间的 Clash 命令行之后，我发现 &lt;a href=&#34;https://github.com/Fndroid/clash_for_windows_pkg/releases&#34;&gt;Clash For Windows&lt;/a&gt; 这个应用也能够在 Linux 下使用。所以最近就切换到了这个应用上。&lt;/p&gt;
&lt;p&gt;另外欢迎订阅使用 &lt;a href=&#34;https://board.gtk.pw/&#34;&gt;EV Proxy&lt;/a&gt; 注册之后一键订阅即可使用。&lt;/p&gt;
&lt;p&gt;下载对应的二进制，比如默认放到 &lt;code&gt;~/Downloads&lt;/code&gt; 目录，在终端进入该目录。&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;gunzip clash-linux-amd64-v0.18.0.gz
sudo mv clash-linux-amd64-v1.4.2 /usr/local/bin/clash
sudo chmod +x /usr/local/bin/clash
./clash
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;clash 启动后会在 &lt;code&gt;~/.config/clash&lt;/code&gt; 目录生成配置文件。&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;ls -al ~/.config/clash
.rw-r--r--   10 einverne 23 Mar 19:30 config.yaml
.rw-r--r-- 4.0M einverne 23 Mar 19:30 Country.mmdb
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;比如说对于我使用的 &lt;a href=&#34;https://portal.wallless.xyz/#/register?code=nlyM4OSi&#34;&gt;Wallless 代理&lt;/a&gt;，在后台复制地址之后，在网址的后面增加 &lt;code&gt;&amp;amp;flag=clash&lt;/code&gt; 获取 clash 的配置文件，右击网页 Save as，选择仅网页内容，下载到本地， &lt;code&gt;sub.html&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;另外还有一个代理，有兴趣的可以&lt;a href=&#34;https://board.gtk.pw/&#34;&gt;试用一下&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;然后将查看 &lt;code&gt;sub.html&lt;/code&gt; 内容，应该是一个 yaml 格式的文件。将此格式的文件替换默认的配置。&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;cat ~/Downloads/sub.html &amp;gt; ~/.config/clash/config.yaml
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;然后重新执行 &lt;code&gt;/usr/local/bin/clash&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;此时检查一下配置中的 socks 端口，我一般用本地的 1080，修改一下:&lt;/p&gt;
&lt;p&gt;然后再运行。去浏览器中，访问 youtube.com 检查一下。&lt;/p&gt;
&lt;p&gt;如果正常访问即完成了配置。&lt;/p&gt;
&lt;p&gt;在配置开机启动之前，将配置文件移动到 &lt;code&gt;/etc&lt;/code&gt; 目录：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;socks-port: 1080
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;以后修改配置都记住修改 &lt;code&gt;/etc/clash&lt;/code&gt; 目录下的这个配置文件。&lt;/p&gt;
&lt;p&gt;然后使用 &lt;code&gt;vi&lt;/code&gt; 增加 systemd 配置 &lt;code&gt;sudo vi /systemd/system/clash.service&lt;/code&gt; 放入如下内容：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;sudo mv ~/.config/clash /etc
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;启用 clash service:&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;[Unit]
Description=Clash Daemon

[Service]
ExecStart=/usr/local/bin/clash -d /etc/clash/
Restart=on-failure

[Install]
WantedBy=multi-user.target
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;手动启动 clash.service:&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;sudo systemctl enable clash.service
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;可以使用 systemd 提供的 &lt;code&gt;disable&lt;/code&gt;, &lt;code&gt;stop&lt;/code&gt; 等等命令来管理。&lt;/p&gt;
&lt;p&gt;如果要查看 Clash service 的日志可以使用：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;sudo systemctl start clash.service
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;如果想要将日志单独记录到文件，可以使用 systemd 的 &lt;code&gt;StandardOutput&lt;/code&gt; 和 &lt;code&gt;StandardError&lt;/code&gt; 将日志定向到文件中。这部分可以参考 &lt;a href=&#34;https://www.freedesktop.org/software/systemd/man/systemd.exec.html#StandardOutput=&#34;&gt;systemd 的文档&lt;/a&gt;&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;journalctl -e -u clash.service
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Clash 提供了默认的 9090 端口作为远端管理端口，在配置中可以看到：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;# Works only in systemd v240 and newer!
StandardOutput=append:/var/log/clash/log.log
StandardError=append:/var/log/clash/error.log
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;这样的配置。&lt;/p&gt;
&lt;p&gt;可以使用 Clash 远程管理的页面进行管理: &lt;a href=&#34;http://clash.razord.top/#/proxies&#34;&gt;http://clash.razord.top/#/proxies&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;这个页面要求提供，Host,Port,Secret 三个输入：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Host: 127.0.0.1&lt;/li&gt;
&lt;li&gt;Port: 9090&lt;/li&gt;
&lt;li&gt;Secret: 配置文件配置的 secret&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;其中 Secret 是在配置文件中通过：&lt;/p&gt;
&lt;p&gt;进行配置的。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://einverne.github.io/post/2017/02/terminal-sock5-proxy.html&#34;&gt;在终端下使用 socks 代理&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;你还可以在终端下对代理进行&lt;a href=&#34;https://einverne.github.io/post/2020/04/how-to-speed-test-a-proxy-socks-or-http-proxy.html&#34;&gt;测速&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;感谢 BobMaster 在评论里面提供其他解决方式，有兴趣可以尝试 &lt;a href=&#34;https://github.com/v2rayA/v2rayA&#34;&gt;v2rayA&lt;/a&gt;， 或 &lt;a href=&#34;https://github.com/Qv2ray/Qv2ray&#34;&gt;Qv2ray&lt;/a&gt;&lt;/p&gt;
- https://shenyiminghfut.github.io/posts/%E5%9C%A8-linux-%E4%B8%8A%E4%BD%BF%E7%94%A8-clash-%E4%BD%9C%E4%BB%A3%E7%90%86-verne-in-github/ - This is a customized copyright.</description>
        </item>
    
    
    
        <item>
        <title>会用 Markdown 还不够，还得知道排版规范</title>
        <link>https://shenyiminghfut.github.io/posts/markdown%E6%8E%92%E7%89%88%E8%A7%84%E8%8C%83/</link>
        <pubDate>Sat, 13 Mar 2021 10:58:08 -0400</pubDate>
        
        <guid>https://shenyiminghfut.github.io/posts/markdown%E6%8E%92%E7%89%88%E8%A7%84%E8%8C%83/</guid>
        <description>摆人日寄 https://shenyiminghfut.github.io/posts/markdown%E6%8E%92%E7%89%88%E8%A7%84%E8%8C%83/ -&lt;p&gt;本文将会介绍 Markdown 中&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Markdown 标记的使用规范&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;使用空格、空行、缩进等元素优化排版的方法&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;常用中文标点符号规范&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;这些是 Markdown 写作的比较常见的排版格式指导，同时也是排版格式约定。遵守它们能使得排版更加美观，更加方便阅读，也能让你有固定的模式可依，降低写作时对于排版的心智负担。&lt;/p&gt;
&lt;h3 id=&#34;markdown-标记的使用规范&#34;&gt;Markdown 标记的使用规范&lt;/h3&gt;
&lt;h4 id=&#34;标题&#34;&gt;标题&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;文章的顶层标题使用&lt;strong&gt;二级标题&lt;/strong&gt;（有时文章的标题并不需要写在文章里，比如大多数博客有专门的位置填写文章标题，此时这级标题可以省略）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;每个小节的标题使用&lt;strong&gt;三级标题&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;小节中进一步分层组织时使用&lt;strong&gt;四级标题&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;尽量少用&lt;strong&gt;五级标题&lt;/strong&gt;和&lt;strong&gt;六级标题&lt;/strong&gt;，考虑用有序列表和无序列表代替&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;完全不用&lt;strong&gt;一级标题&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;粗体斜体&#34;&gt;粗体、斜体&lt;/h4&gt;
&lt;p&gt;需要强调某处内容时使用&lt;strong&gt;粗体&lt;/strong&gt;，如：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;中文全角标点符号占&lt;strong&gt;一个&lt;/strong&gt;汉字宽度，英文半角标点占&lt;strong&gt;半个&lt;/strong&gt;汉字宽度（亦即一个字母宽度）。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;在中文排版中不使用&lt;strong&gt;斜体&lt;/strong&gt;。在英文排版中可用斜体表达强调，或表示书名、题目。&lt;/p&gt;
&lt;h4 id=&#34;引用块&#34;&gt;引用块&lt;/h4&gt;
&lt;p&gt;以下情况使用引用块：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;引述内容时（也可直接用引号替代）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;作示例时&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;给出提示、补充、警告等额外说明时&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;行内代码&#34;&gt;行内代码&lt;/h4&gt;
&lt;p&gt;某一行文字中嵌入简短代码时使用&lt;strong&gt;行内代码&lt;/strong&gt;，如：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;打开 Linux 虚拟终端，输入 &lt;code&gt;echo &#39;Hello World&#39;&lt;/code&gt;。恭喜，你已经入门 Shell 了！&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&#34;代码块&#34;&gt;代码块&lt;/h4&gt;
&lt;p&gt;展示多行代码时使用&lt;strong&gt;代码块&lt;/strong&gt;，也可用于 XML、JSON、配置项等。尽量在使用代码块时给出语言标识，因为大多数 Markdown 工具会针对该语言高亮显示其中的语言元素。如：&lt;/p&gt;
&lt;blockquote&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code class=&#34;language-**java**&#34; data-lang=&#34;**java**&#34;&gt;public class Main {  
 public static void main(String[] args) {  
 System.out.println(&amp;#34;Hello World&amp;#34;);  
 }  
}  
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;将显示为：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;public class Main {    public static void main(String[] args) {        System.out.println(&amp;#34;Hello World&amp;#34;);    }}
&lt;/code&gt;&lt;/pre&gt;&lt;/blockquote&gt;
&lt;h4 id=&#34;图片&#34;&gt;图片&lt;/h4&gt;
&lt;p&gt;Markdown 中使用 &lt;code&gt;![图片名称](https://xx.xx/xx)&lt;/code&gt;的方式来插入图片，这里的「图片名称」可以任取，但是推荐使用对图片主题具有描述性的文字。因为在一些网站或软件中，图片无法加载时会显示这个「图片名称」，这时至少还能给读者传递出一点有用信息。&lt;/p&gt;
&lt;h4 id=&#34;转义符号&#34;&gt;转义符号&lt;/h4&gt;
&lt;p&gt;如果不想让 Markdown 标记生效，可以在标记的每个符号前加上反斜杠（&lt;code&gt;\&lt;/code&gt;），这样这些符号将按原样显示，不再具有 Markdown 中的特殊意义。&lt;/p&gt;
&lt;p&gt;如：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;不想让引用块标记生效，可以使用 &lt;code&gt;\&amp;gt;&lt;/code&gt;，将显示为 &lt;code&gt;&amp;gt;&lt;/code&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;不想让二级标题标记生效，可以使用 &lt;code&gt;\#\#&lt;/code&gt;，将显示为 &lt;code&gt;##&lt;/code&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;空白符号的运用&#34;&gt;空白符号的运用&lt;/h3&gt;
&lt;h4 id=&#34;空格&#34;&gt;空格&lt;/h4&gt;
&lt;p&gt;Markdown 中&lt;strong&gt;半角空格&lt;/strong&gt;的使用很重要，一些情况下能调节文字间距使得排版更加美观。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;中英文混排时，英文前后各加一个空格，如：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;请坚信 Markdown 会为你带来生产力的提升。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;中文和阿拉伯数字混排时，数字前后各加一个空格，如：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;2008 年已经过去 11 年了！&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;若英文或阿拉伯数字紧邻中文全角标点，则其与标点之间&lt;strong&gt;不加&lt;/strong&gt;空格，如：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;有了 Markdown，可以不再用 Word。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;行内代码的两端各添加一个空格。若行内代码紧邻标点符号，则其与标点之间&lt;strong&gt;不加&lt;/strong&gt;空格&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;打开 Linux 虚拟终端，输入 &lt;code&gt;echo &#39;Hello World&#39;&lt;/code&gt;。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&#34;空行&#34;&gt;空行&lt;/h4&gt;
&lt;p&gt;正文段落之间用一个空行来分隔，可以显得段落分明、结构不拥挤，如：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Markdown 是一种标记语言。在写作时，你的所有文字都是没有样式的纯文本，在其中插入若干 Markdown 标记后，被标记的文字便有了样式。&lt;/p&gt;
&lt;p&gt;比如，在你所写的文字中，希望某一行的最终排版呈现一级标题的样式，那就给这行文字加个一级标题的标记；某个地方有两个字需要加粗，那就给这两个字加个粗体标记。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&#34;缩进&#34;&gt;缩进&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;文章中每个段落的开头&lt;strong&gt;不要&lt;/strong&gt;缩进&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;列表中嵌套列表时，内层列表使用 4 个空格进行缩进，如：&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;blockquote&gt;
&lt;ol&gt;
&lt;li&gt;外层列表 1&lt;/li&gt;
&lt;li&gt;外层列表 2&lt;br&gt;
    1. 内层列表 a&lt;br&gt;
    2. 内层列表 b&lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;想要像上面那样在一个列表项中嵌入引用块，只要在 Markdown 中将引用块用 4 个空格缩进。除此之外，图片、代码块等元素也可以在列表下缩进&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;缩进时使用空格符，不用 Tab 符&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;中文标点符号规范&#34;&gt;中文标点符号规范&lt;/h3&gt;
&lt;h4 id=&#34;标点通用规则&#34;&gt;标点通用规则&lt;/h4&gt;
&lt;p&gt;中文排版时应全文使用中文全角标点，无论内容中是否包含英文词语。除非内容中包含完整的英文句子或段落，这种情况下英文内的标点使用半角标点。&lt;/p&gt;
&lt;h4 id=&#34;引号&#34;&gt;引号&lt;/h4&gt;
&lt;p&gt;网络文章排版时使用直角引号——单引号「」，双引号『』。通常先使用「」，在引号嵌套时才在内层用『』。&lt;/p&gt;
&lt;p&gt;直角引号在自媒体中比较常见，但也会有一些争议。&lt;/p&gt;
&lt;h4 id=&#34;省略号&#34;&gt;省略号&lt;/h4&gt;
&lt;p&gt;在中文输入法状态下，可使用 &lt;code&gt;Shift + 6&lt;/code&gt; 输入省略号。注意是 6 个点，而非 3 个点，如：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;中文里常用的标点有逗号、句号、顿号、冒号……&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&#34;破折号&#34;&gt;破折号&lt;/h4&gt;
&lt;p&gt;在中文输入法状态下，可使用 &lt;code&gt;Shift + -&lt;/code&gt; 输入破折号。注意该符号应占两个汉字宽度，如：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;破折号，标示语段中某些成分的注释、补充说明或语音、意义的变化。——《标点符号用法》&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&#34;波浪线&#34;&gt;波浪线&lt;/h4&gt;
&lt;p&gt;在中文输入法状态下，可使用 &lt;code&gt;Shift + ` &lt;/code&gt;（在 ESC 键下方） 输入波浪线。可用波浪线表示数值的区间，如：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;只要 10～20 分钟你便能掌握这篇文章的要领。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;注意，日期时间或地名的区间用破折号表示，如&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;某班上海——北京的高铁的运行时间是 10:00——16:00。&lt;/p&gt;
&lt;/blockquote&gt;
- https://shenyiminghfut.github.io/posts/markdown%E6%8E%92%E7%89%88%E8%A7%84%E8%8C%83/ - This is a customized copyright.</description>
        </item>
    
    
    
        <item>
        <title> Vim命令速查</title>
        <link>https://shenyiminghfut.github.io/posts/vim-%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E9%80%9F%E6%9F%A5/</link>
        <pubDate>Tue, 09 Mar 2021 10:58:08 -0400</pubDate>
        
        <guid>https://shenyiminghfut.github.io/posts/vim-%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E9%80%9F%E6%9F%A5/</guid>
        <description>摆人日寄 https://shenyiminghfut.github.io/posts/vim-%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E9%80%9F%E6%9F%A5/ -&lt;blockquote&gt;
&lt;p&gt;本速查表按分类列出了 Vim 常用的命令和快捷键，数量较多，可使用 Ctrl + F 进行查找。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;全局命令&#34;&gt;全局命令&lt;/h2&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th width=&#34;30%&#34;&gt;命令 / 快捷键&lt;/th&gt;&lt;th&gt;功能描述&lt;/th&gt;&lt;/tr&gt;&lt;/thead&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;&lt;kbd&gt;:h[elp] 关键字&lt;/kbd&gt;&lt;/td&gt;&lt;td&gt;显示指定关键字的帮助&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;kbd&gt;:sav[eas] 文件名&lt;/kbd&gt;&lt;/td&gt;&lt;td&gt;另存为...&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;kbd&gt;:clo[se]&lt;/kbd&gt;&lt;/td&gt;&lt;td&gt;关闭当前窗口&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;kbd&gt;:ter[minal]&lt;/kbd&gt;&lt;/td&gt;&lt;td&gt;打开新的终端窗口&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;kbd&gt;K&lt;/kbd&gt;&lt;/td&gt;&lt;td&gt;打开光标所在单词对应的 man 页面&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;
&lt;h2 id=&#34;移动光标&#34;&gt;移动光标&lt;/h2&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th width=&#34;30%&#34;&gt;命令 / 快捷键&lt;/th&gt;&lt;th&gt;功能描述&lt;/th&gt;&lt;/tr&gt;&lt;/thead&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;&lt;kbd&gt;h&lt;/kbd&gt;&lt;/td&gt;&lt;td&gt;左移光标&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;kbd&gt;j&lt;/kbd&gt;&lt;/td&gt;&lt;td&gt;下移光标&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;kbd&gt;k&lt;/kbd&gt;&lt;/td&gt;&lt;td&gt;上移光标&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;kbd&gt;l&lt;/kbd&gt;&lt;/td&gt;&lt;td&gt;右移光标&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;kbd&gt;H&lt;/kbd&gt;&lt;/td&gt;&lt;td&gt;移动到当前页面顶部&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;kbd&gt;M&lt;/kbd&gt;&lt;/td&gt;&lt;td&gt;移动到当前页面中间&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;kbd&gt;L&lt;/kbd&gt;&lt;/td&gt;&lt;td&gt;移动到当前页面底部&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;kbd&gt;w&lt;/kbd&gt;&lt;/td&gt;&lt;td&gt;移动到下个单词开头&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;kbd&gt;W&lt;/kbd&gt;&lt;/td&gt;&lt;td&gt;移动到下个单词开头（单词含标点）&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;kbd&gt;e&lt;/kbd&gt;&lt;/td&gt;&lt;td&gt;移动到下个单词结尾&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;kbd&gt;E&lt;/kbd&gt;&lt;/td&gt;&lt;td&gt;移动到下个单词结尾（单词含标点）&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;kbd&gt;b&lt;/kbd&gt;&lt;/td&gt;&lt;td&gt;移动到上个单词开头&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;kbd&gt;B&lt;/kbd&gt;&lt;/td&gt;&lt;td&gt;移动到上个单词开头（单词含标点）&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;kbd&gt;%&lt;/kbd&gt;&lt;/td&gt;&lt;td&gt;跳转到配对的符号&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;kbd&gt;0&lt;/kbd&gt;&lt;/td&gt;&lt;td&gt;移动到行首&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;kbd&gt;^&lt;/kbd&gt;&lt;/td&gt;&lt;td&gt;移动到行首的非空白符&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;kbd&gt;$&lt;/kbd&gt;&lt;/td&gt;&lt;td&gt;移动到行尾&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;kbd&gt;g_&lt;/kbd&gt;&lt;/td&gt;&lt;td&gt;移动到行内最后一个非空白符&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;kbd&gt;gg&lt;/kbd&gt;&lt;/td&gt;&lt;td&gt;移动到文件第一行&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;kbd&gt;G&lt;/kbd&gt;&lt;/td&gt;&lt;td&gt;移动到文件最后一行&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;kbd&gt;5gg&lt;/kbd&gt; 或 &lt;kbd&gt;5G&lt;/kbd&gt;&lt;/td&gt;&lt;td&gt;移动到第 5 行&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;kbd&gt;fx&lt;/kbd&gt;&lt;/td&gt;&lt;td&gt;移动到字符 &lt;code&gt;x&lt;/code&gt; 下次出现的位置&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;kbd&gt;tx&lt;/kbd&gt;&lt;/td&gt;&lt;td&gt;移动到字符 &lt;code&gt;x&lt;/code&gt; 下次出现的位置的前一个字符&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;kbd&gt;Fx&lt;/kbd&gt;&lt;/td&gt;&lt;td&gt;移动到字符 &lt;code&gt;x&lt;/code&gt; 上次出现的位置&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;kbd&gt;Tx&lt;/kbd&gt;&lt;/td&gt;&lt;td&gt;移动到字符 &lt;code&gt;x&lt;/code&gt; 上次出现的位置的后一个字符&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;kbd&gt;;&lt;/kbd&gt;&lt;/td&gt;&lt;td&gt;重复之前的 &lt;kbd&gt;f&lt;/kbd&gt;、&lt;kbd&gt;t&lt;/kbd&gt;、&lt;kbd&gt;F&lt;/kbd&gt;、&lt;kbd&gt;T&lt;/kbd&gt; 操作&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;kbd&gt;,&lt;/kbd&gt;&lt;/td&gt;&lt;td&gt;反向重复之前的 &lt;kbd&gt;f&lt;/kbd&gt;、&lt;kbd&gt;t&lt;/kbd&gt;、&lt;kbd&gt;F&lt;/kbd&gt;、&lt;kbd&gt;T&lt;/kbd&gt; 操作&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;kbd&gt;}&lt;/kbd&gt;&lt;/td&gt;&lt;td&gt;移动到下一个段落（当编辑代码时则为函数／代码块）&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;kbd&gt;{&lt;/kbd&gt;&lt;/td&gt;&lt;td&gt;移动到上一个段落（当编辑代码时则为函数／代码块）&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;kbd&gt;zz&lt;/kbd&gt;&lt;/td&gt;&lt;td&gt;移动屏幕使光标居中&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;kbd&gt;Ctrl&lt;/kbd&gt; + &lt;kbd&gt;e&lt;/kbd&gt;&lt;/td&gt;&lt;td&gt;向下移动屏幕一行（保持光标不动）&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;kbd&gt;Ctrl&lt;/kbd&gt; + &lt;kbd&gt;y&lt;/kbd&gt;&lt;/td&gt;&lt;td&gt;向上移动屏幕一行（保持光标不动）&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;kbd&gt;Ctrl&lt;/kbd&gt; + &lt;kbd&gt;b&lt;/kbd&gt;&lt;/td&gt;&lt;td&gt;向上滚动一屏&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;kbd&gt;Ctrl&lt;/kbd&gt; + &lt;kbd&gt;f&lt;/kbd&gt;&lt;/td&gt;&lt;td&gt;向下滚动一屏&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;kbd&gt;Ctrl&lt;/kbd&gt; + &lt;kbd&gt;d&lt;/kbd&gt;&lt;/td&gt;&lt;td&gt;向下滚动半屏&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;kbd&gt;Ctrl&lt;/kbd&gt; + &lt;kbd&gt;u&lt;/kbd&gt;&lt;/td&gt;&lt;td&gt;向上滚动半屏&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;
&lt;h2 id=&#34;插入模式插入--追加文本&#34;&gt;插入模式（插入 / 追加文本）&lt;/h2&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th width=&#34;30%&#34;&gt;命令 / 快捷键&lt;/th&gt;&lt;th&gt;功能描述&lt;/th&gt;&lt;/tr&gt;&lt;/thead&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;&lt;kbd&gt;i&lt;/kbd&gt;&lt;/td&gt;&lt;td&gt;从光标前开始插入字符&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;kbd&gt;I&lt;/kbd&gt;&lt;/td&gt;&lt;td&gt;从行首开始插入字符&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;kbd&gt;a&lt;/kbd&gt;&lt;/td&gt;&lt;td&gt;从光标后开始插入字符&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;kbd&gt;A&lt;/kbd&gt;&lt;/td&gt;&lt;td&gt;从行尾开始插入字符&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;kbd&gt;o&lt;/kbd&gt;&lt;/td&gt;&lt;td&gt;在当前行之下另起一行，开始插入字符&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;kbd&gt;O&lt;/kbd&gt;&lt;/td&gt;&lt;td&gt;在当前行之上另起一行，开始插入字符&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;kbd&gt;ea&lt;/kbd&gt;&lt;/td&gt;&lt;td&gt;从当前单词末尾开始插入&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;kbd&gt;Ctrl&lt;/kbd&gt; + &lt;kbd&gt;h&lt;/kbd&gt;&lt;/td&gt;&lt;td&gt;在插入模式下，删除光标前的字符&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;kbd&gt;Ctrl&lt;/kbd&gt; + &lt;kbd&gt;w&lt;/kbd&gt;&lt;/td&gt;&lt;td&gt;在插入模式下，删除光标前的单词&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;kbd&gt;Ctrl&lt;/kbd&gt; + &lt;kbd&gt;j&lt;/kbd&gt;&lt;/td&gt;&lt;td&gt;在插入模式下，另起一行&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;kbd&gt;Ctrl&lt;/kbd&gt; + &lt;kbd&gt;t&lt;/kbd&gt;&lt;/td&gt;&lt;td&gt;在插入模式下，向右缩进，宽度由 &lt;code&gt;shiftwidth&lt;/code&gt; 控制&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;kbd&gt;Ctrl&lt;/kbd&gt; + &lt;kbd&gt;d&lt;/kbd&gt;&lt;/td&gt;&lt;td&gt;在插入模式下，向左缩进，宽度由 &lt;code&gt;shiftwidth&lt;/code&gt; 控制&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;kbd&gt;Ctrl&lt;/kbd&gt; + &lt;kbd&gt;n&lt;/kbd&gt;&lt;/td&gt;&lt;td&gt;在插入模式下，在光标之前插入自动补全的下一个匹配项&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;kbd&gt;Ctrl&lt;/kbd&gt; + &lt;kbd&gt;p&lt;/kbd&gt;&lt;/td&gt;&lt;td&gt;在插入模式下，在光标之前插入自动补全的上一个匹配项&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;kbd&gt;Ctrl&lt;/kbd&gt; + &lt;kbd&gt;rx&lt;/kbd&gt;&lt;/td&gt;&lt;td&gt;在当前光标处插入 x 寄存器的内容&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;kbd&gt;Esc&lt;/kbd&gt;&lt;/td&gt;&lt;td&gt;退出插入模式&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;
&lt;h2 id=&#34;编辑文本&#34;&gt;编辑文本&lt;/h2&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th width=&#34;30%&#34;&gt;命令 / 快捷键&lt;/th&gt;&lt;th&gt;功能描述&lt;/th&gt;&lt;/tr&gt;&lt;/thead&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;&lt;kbd&gt;r&lt;/kbd&gt;&lt;/td&gt;&lt;td&gt;替换当前字符&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;kbd&gt;J&lt;/kbd&gt;&lt;/td&gt;&lt;td&gt;将下一行合并到当前行，并在两部分文本之间插入一个空格&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;kbd&gt;gJ&lt;/kbd&gt;&lt;/td&gt;&lt;td&gt;将下一行合并到当前行，两部分文本之间不含空格&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;kbd&gt;gwip&lt;/kbd&gt;&lt;/td&gt;&lt;td&gt;重新调整段落&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;kbd&gt;g~&lt;/kbd&gt;&lt;/td&gt;&lt;td&gt;切换整个文本的大小写（即大写变小写，小写变大写）&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;kbd&gt;gu&lt;/kbd&gt;&lt;/td&gt;&lt;td&gt;把整个文本改成小写&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;kbd&gt;gU&lt;/kbd&gt;&lt;/td&gt;&lt;td&gt;把整个文本改成大写&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;kbd&gt;cc&lt;/kbd&gt; 或 &lt;kbd&gt;S&lt;/kbd&gt;&lt;/td&gt;&lt;td&gt;将光标所在的行删除，然后进入插入模式&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;kbd&gt;C&lt;/kbd&gt; 或 &lt;kbd&gt;c$&lt;/kbd&gt;&lt;/td&gt;&lt;td&gt;删除光标所在位置到行尾的所有文本，然后进入插入模式&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;kbd&gt;ciw&lt;/kbd&gt;&lt;/td&gt;&lt;td&gt;将光标所在的单词删除，然后进入插入模式&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;kbd&gt;cw&lt;/kbd&gt;&lt;/td&gt;&lt;td&gt;从光标位置开始，修改单词&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;kbd&gt;s&lt;/kbd&gt;&lt;/td&gt;&lt;td&gt;删除当前字符，然后进入插入模式&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;kbd&gt;xp&lt;/kbd&gt;&lt;/td&gt;&lt;td&gt;将当前字符后移&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;kbd&gt;u&lt;/kbd&gt;&lt;/td&gt;&lt;td&gt;undo - 撤销最近一次操作&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;kbd&gt;U&lt;/kbd&gt;&lt;/td&gt;&lt;td&gt;恢复 / 撤销最后修改的行&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;kbd&gt;Ctrl&lt;/kbd&gt; + &lt;kbd&gt;r&lt;/kbd&gt;&lt;/td&gt;&lt;td&gt;redo - 重做（和 &lt;kbd&gt;u&lt;/kbd&gt; 相反）&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;kbd&gt;.&lt;/kbd&gt;&lt;/td&gt;&lt;td&gt;再次执行上一个命令&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;
&lt;h2 id=&#34;选择文本可视化模式&#34;&gt;选择文本（可视化模式）&lt;/h2&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th width=&#34;30%&#34;&gt;命令 / 快捷键&lt;/th&gt;&lt;th&gt;功能描述&lt;/th&gt;&lt;/tr&gt;&lt;/thead&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;&lt;kbd&gt;v&lt;/kbd&gt;&lt;/td&gt;&lt;td&gt;进入可视化模式，移动光标高亮选择，然后，可以对被选中的文本执行命令&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;kbd&gt;V&lt;/kbd&gt;&lt;/td&gt;&lt;td&gt;进行可视化模式，以行为单位进行选择&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;kbd&gt;o&lt;/kbd&gt;&lt;/td&gt;&lt;td&gt;在可视化模式下，让光标在选择区域的开头和结尾进行切换&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;kbd&gt;O&lt;/kbd&gt;&lt;/td&gt;&lt;td&gt;在可视化模式下，切换光标到选择区域的角&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;kbd&gt;Ctrl&lt;/kbd&gt; + &lt;kbd&gt;v&lt;/kbd&gt;&lt;/td&gt;&lt;td&gt;进入可视化模式，矩阵选择（即列模式）&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;kbd&gt;aw&lt;/kbd&gt;&lt;/td&gt;&lt;td&gt;在可视化模式下，选择当前单词&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;kbd&gt;ab&lt;/kbd&gt;&lt;/td&gt;&lt;td&gt;在可视化模式下，选择被 &lt;code&gt;()&lt;/code&gt; 包裹的区域的内容（包含括号）&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;kbd&gt;aB&lt;/kbd&gt;&lt;/td&gt;&lt;td&gt;在可视化模式下，选择被 &lt;code&gt;{}&lt;/code&gt; 包裹的区域的内容（包含花括号）&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;kbd&gt;at&lt;/kbd&gt;&lt;/td&gt;&lt;td&gt;在可视化模式下，选择被 &lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt; 包裹的区域的内容（包含 &amp;lt;&amp;gt; 标签）&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;kbd&gt;ib&lt;/kbd&gt;&lt;/td&gt;&lt;td&gt;在可视化模式下，选择被 &lt;code&gt;()&lt;/code&gt; 包裹的区域的内容（不包含括号）&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;kbd&gt;iB&lt;/kbd&gt;&lt;/td&gt;&lt;td&gt;在可视化模式下，选择被 &lt;code&gt;{}&lt;/code&gt; 包裹的区域的内容（不包含花括号）&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;kbd&gt;it&lt;/kbd&gt;&lt;/td&gt;&lt;td&gt;在可视化模式下，选择被 &lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt; 包裹的区域的内容（不包含 &amp;lt;&amp;gt; 标签）&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;kbd&gt;Esc&lt;/kbd&gt;&lt;/td&gt;&lt;td&gt;退出可视化模式&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;
&lt;h2 id=&#34;可视化模式命令&#34;&gt;可视化模式命令&lt;/h2&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th width=&#34;30%&#34;&gt;命令 / 快捷键&lt;/th&gt;&lt;th&gt;功能描述&lt;/th&gt;&lt;/tr&gt;&lt;/thead&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;&lt;kbd&gt;&amp;gt;&lt;/kbd&gt;&lt;/td&gt;&lt;td&gt;向右缩进&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;kbd&gt;&amp;lt;&lt;/kbd&gt;&lt;/td&gt;&lt;td&gt;向左缩进&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;kbd&gt;y&lt;/kbd&gt;&lt;/td&gt;&lt;td&gt;复制选中的文本&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;kbd&gt;d&lt;/kbd&gt;&lt;/td&gt;&lt;td&gt;剪切选中的文本&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;kbd&gt;~&lt;/kbd&gt;&lt;/td&gt;&lt;td&gt;对选中的文本进行大小写切换&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;kbd&gt;u&lt;/kbd&gt;&lt;/td&gt;&lt;td&gt;将选中的文本转换为小写&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;kbd&gt;U&lt;/kbd&gt;&lt;/td&gt;&lt;td&gt;将选中的文本转换为大写&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;
&lt;h2 id=&#34;寄存器&#34;&gt;寄存器&lt;/h2&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th width=&#34;30%&#34;&gt;命令 / 快捷键&lt;/th&gt;&lt;th&gt;功能描述&lt;/th&gt;&lt;/tr&gt;&lt;/thead&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;&lt;kbd&gt;:reg[isters]&lt;/kbd&gt;&lt;/td&gt;&lt;td&gt;显示寄存器的内容&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;kbd&gt;&#34;xy&lt;/kbd&gt;&lt;/td&gt;&lt;td&gt;复制内容到寄存器 x&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;kbd&gt;&#34;xp&lt;/kbd&gt;&lt;/td&gt;&lt;td&gt;粘贴寄存器 x 中的内容&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;kbd&gt;&#34;+y&lt;/kbd&gt;&lt;/td&gt;&lt;td&gt;复制内容到系统剪贴板寄存器&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;kbd&gt;&#34;+p&lt;/kbd&gt;&lt;/td&gt;&lt;td&gt;粘贴系统剪贴板寄存器的内容&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;
&lt;h2 id=&#34;标记和位置&#34;&gt;标记和位置&lt;/h2&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th width=&#34;30%&#34;&gt;命令 / 快捷键&lt;/th&gt;&lt;th&gt;功能描述&lt;/th&gt;&lt;/tr&gt;&lt;/thead&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;&lt;kbd&gt;:marks&lt;/kbd&gt;&lt;/td&gt;&lt;td&gt;显示标记列表&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;kbd&gt;ma&lt;/kbd&gt;&lt;/td&gt;&lt;td&gt;设置当前位置为标记 a&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;kbd&gt;`a&lt;/kbd&gt;&lt;/td&gt;&lt;td&gt;跳转到标记 a 的位置&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;kbd&gt;`0&lt;/kbd&gt;&lt;/td&gt;&lt;td&gt;跳转到 Vim 上一次退出时的位置&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;kbd&gt;`&#34;&lt;/kbd&gt;&lt;/td&gt;&lt;td&gt;跳转到该文件上次编辑时的位置&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;kbd&gt;`.&lt;/kbd&gt;&lt;/td&gt;&lt;td&gt;跳转到该文件中最后一次修改的位置&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;kbd&gt;``&lt;/kbd&gt;&lt;/td&gt;&lt;td&gt;跳转到最后跳转的位置&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;kbd&gt;:ju[mps]&lt;/kbd&gt;&lt;/td&gt;&lt;td&gt;列出所有跳转&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;kbd&gt;Ctrl&lt;/kbd&gt; + &lt;kbd&gt;i&lt;/kbd&gt;&lt;/td&gt;&lt;td&gt;转到跳转列表较新的位置&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;kbd&gt;Ctrl&lt;/kbd&gt; + &lt;kbd&gt;o&lt;/kbd&gt;&lt;/td&gt;&lt;td&gt;转到跳转列表较旧的位置&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;kbd&gt;:changes&lt;/kbd&gt;&lt;/td&gt;&lt;td&gt;列出所有修改历史&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;kbd&gt;g,&lt;/kbd&gt;&lt;/td&gt;&lt;td&gt;转到修改历史列表较新的位置&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;kbd&gt;g;&lt;/kbd&gt;&lt;/td&gt;&lt;td&gt;转到修改历史列表较旧的位置&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;kbd&gt;Ctrl&lt;/kbd&gt; + &lt;kbd&gt;]&lt;/kbd&gt;&lt;/td&gt;&lt;td&gt;跳转到当前光标所在的标签&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;
&lt;h2 id=&#34;宏&#34;&gt;宏&lt;/h2&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th width=&#34;30%&#34;&gt;命令 / 快捷键&lt;/th&gt;&lt;th&gt;功能描述&lt;/th&gt;&lt;/tr&gt;&lt;/thead&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;&lt;kbd&gt;qa&lt;/kbd&gt;&lt;/td&gt;&lt;td&gt;录制宏 a&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;kbd&gt;q&lt;/kbd&gt;&lt;/td&gt;&lt;td&gt;停止录制宏&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;kbd&gt;@a&lt;/kbd&gt;&lt;/td&gt;&lt;td&gt;执行宏 a&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;kbd&gt;@@&lt;/kbd&gt;&lt;/td&gt;&lt;td&gt;重新执行上次执行的宏&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;
&lt;h2 id=&#34;复制剪切和粘贴&#34;&gt;复制、剪切和粘贴&lt;/h2&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th width=&#34;30%&#34;&gt;命令 / 快捷键&lt;/th&gt;&lt;th&gt;功能描述&lt;/th&gt;&lt;/tr&gt;&lt;/thead&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;&lt;kbd&gt;yy&lt;/kbd&gt;&lt;/td&gt;&lt;td&gt;复制当前行&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;kbd&gt;2yy&lt;/kbd&gt;&lt;/td&gt;&lt;td&gt;复制 2 行&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;kbd&gt;yw&lt;/kbd&gt;&lt;/td&gt;&lt;td&gt;复制当前单词&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;kbd&gt;y$&lt;/kbd&gt;&lt;/td&gt;&lt;td&gt;复制从光标位置开始到行末的内容&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;kbd&gt;p&lt;/kbd&gt;&lt;/td&gt;&lt;td&gt;在光标后粘贴复制的内容&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;kbd&gt;P&lt;/kbd&gt;&lt;/td&gt;&lt;td&gt;在光标前粘贴复制的内容&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;kbd&gt;dd&lt;/kbd&gt;&lt;/td&gt;&lt;td&gt;剪切当前行&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;kbd&gt;2dd&lt;/kbd&gt;&lt;/td&gt;&lt;td&gt;剪切 2 行&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;kbd&gt;dw&lt;/kbd&gt;&lt;/td&gt;&lt;td&gt;剪切当前单词&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;kbd&gt;d$&lt;/kbd&gt; 或 &lt;kbd&gt;D&lt;/kbd&gt;&lt;/td&gt;&lt;td&gt;剪切从光标位置开始到行末的内容&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;kbd&gt;x&lt;/kbd&gt;&lt;/td&gt;&lt;td&gt;剪切当前字符&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;
&lt;h2 id=&#34;文本缩进&#34;&gt;文本缩进&lt;/h2&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th width=&#34;30%&#34;&gt;命令 / 快捷键&lt;/th&gt;&lt;th&gt;功能描述&lt;/th&gt;&lt;/tr&gt;&lt;/thead&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;&lt;kbd&gt;&amp;gt;&amp;gt;&lt;/kbd&gt;&lt;/td&gt;&lt;td&gt;将当前行向右缩进，宽度由 &lt;code&gt;shiftwidth&lt;/code&gt; 控制&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;kbd&gt;&amp;lt;&amp;lt;&lt;/kbd&gt;&lt;/td&gt;&lt;td&gt;将当前行向左缩进，宽度由 &lt;code&gt;shiftwidth&lt;/code&gt; 控制&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;kbd&gt;&amp;gt;%&lt;/kbd&gt;&lt;/td&gt;&lt;td&gt;向右缩进 &lt;code&gt;()&lt;/code&gt; 或 &lt;code&gt;{}&lt;/code&gt; 内的区域（光标需置于括号上）&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;kbd&gt;&amp;gt;ib&lt;/kbd&gt;&lt;/td&gt;&lt;td&gt;向右缩进 &lt;code&gt;()&lt;/code&gt; 内的区域（光标需置于括号上）&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;kbd&gt;&amp;gt;at&lt;/kbd&gt;&lt;/td&gt;&lt;td&gt;向右缩进 &lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt; 标签内的区域（光标需置于 &amp;lt;&amp;gt; 标签上）&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;kbd&gt;3==&lt;/kbd&gt;&lt;/td&gt;&lt;td&gt;自动缩进 3 行&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;kbd&gt;=%&lt;/kbd&gt;&lt;/td&gt;&lt;td&gt;自动缩进 &lt;code&gt;()&lt;/code&gt; 或 &lt;code&gt;{}&lt;/code&gt; 内的区域（光标需置于括号上）&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;kbd&gt;=iB&lt;/kbd&gt;&lt;/td&gt;&lt;td&gt;自动缩进 &lt;code&gt;{}&lt;/code&gt; 内的区域（光标需置于括号上）&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;kbd&gt;gg=G&lt;/kbd&gt;&lt;/td&gt;&lt;td&gt;自动缩进整个缓冲区&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;kbd&gt;]p&lt;/kbd&gt;&lt;/td&gt;&lt;td&gt;粘贴并调整缩进至当前行&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;
&lt;h2 id=&#34;文本搜索和替换&#34;&gt;文本搜索和替换&lt;/h2&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th width=&#34;30%&#34;&gt;命令 / 快捷键&lt;/th&gt;&lt;th&gt;功能描述&lt;/th&gt;&lt;/tr&gt;&lt;/thead&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;&lt;kbd&gt;/pattern&lt;/kbd&gt;&lt;/td&gt;&lt;td&gt;在当前文本中查找 &lt;code&gt;pattern&lt;/code&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;kbd&gt;?pattern&lt;/kbd&gt;&lt;/td&gt;&lt;td&gt;向上查找 &lt;code&gt;pattern&lt;/code&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;kbd&gt;\vpattern&lt;/kbd&gt;&lt;/td&gt;&lt;td&gt;把 &lt;code&gt;pattern&lt;/code&gt; 中的非字母数字字符视为正则表达式特殊字符（不需转义字符）&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;kbd&gt;n&lt;/kbd&gt;&lt;/td&gt;&lt;td&gt;查找下一个&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;kbd&gt;N&lt;/kbd&gt;&lt;/td&gt;&lt;td&gt;查找上一个&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;kbd&gt;:%s/old/new/g&lt;/kbd&gt;&lt;/td&gt;&lt;td&gt;把 &lt;code&gt;old&lt;/code&gt; 全部替换成 &lt;code&gt;new&lt;/code&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;kbd&gt;:%s/old/new/gc&lt;/kbd&gt;&lt;/td&gt;&lt;td&gt;把 &lt;code&gt;old&lt;/code&gt; 逐个替换成 &lt;code&gt;new&lt;/code&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;kbd&gt;:noh[lsearch]&lt;/kbd&gt;&lt;/td&gt;&lt;td&gt;移除搜索结果的高亮显示&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;
&lt;h2 id=&#34;多文件编辑&#34;&gt;多文件编辑&lt;/h2&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th width=&#34;30%&#34;&gt;命令 / 快捷键&lt;/th&gt;&lt;th&gt;功能描述&lt;/th&gt;&lt;/tr&gt;&lt;/thead&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;&lt;kbd&gt;:e[dit] 文件名&lt;/kbd&gt;&lt;/td&gt;&lt;td&gt;在新建的缓冲区打开指定文件名的文件&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;kbd&gt;:bn[ext]&lt;/kbd&gt;&lt;/td&gt;&lt;td&gt;切换到下一个缓冲区&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;kbd&gt;:bp[revious]&lt;/kbd&gt;&lt;/td&gt;&lt;td&gt;切换到上一个缓冲区&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;kbd&gt;:bd[elete]&lt;/kbd&gt;&lt;/td&gt;&lt;td&gt;关闭缓冲区&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;kbd&gt;:b[uffer]2&lt;/kbd&gt;&lt;/td&gt;&lt;td&gt;切换到第 2 个缓冲区&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;kbd&gt;:b[uffer] 文件&lt;/kbd&gt;&lt;/td&gt;&lt;td&gt;切换到指定文件的缓冲区&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;kbd&gt;:ls&lt;/kbd&gt; 或 &lt;kbd&gt;:buffers&lt;/kbd&gt;&lt;/td&gt;&lt;td&gt;列出所有打开的缓冲区&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;kbd&gt;:sp[lit] 文件名&lt;/kbd&gt;&lt;/td&gt;&lt;td&gt;在新建的缓冲区打开指定文件名的文件，并水平分割窗口&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;kbd&gt;:vs[lit] 文件名&lt;/kbd&gt;&lt;/td&gt;&lt;td&gt;在新建的缓冲区打开指定文件名的文件，并垂直分割窗口&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;kbd&gt;:vert[ical] ba[ll]&lt;/kbd&gt;&lt;/td&gt;&lt;td&gt;以垂直窗口的形式编辑所有缓冲区&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;kbd&gt;:tab ba[ll]&lt;/kbd&gt;&lt;/td&gt;&lt;td&gt;以标签的形式编辑所有缓冲区&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;kbd&gt;Ctrl&lt;/kbd&gt; + &lt;kbd&gt;ws&lt;/kbd&gt;&lt;/td&gt;&lt;td&gt;水平分割窗口&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;kbd&gt;Ctrl&lt;/kbd&gt; + &lt;kbd&gt;wv&lt;/kbd&gt;&lt;/td&gt;&lt;td&gt;垂直分割窗口&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;kbd&gt;Ctrl&lt;/kbd&gt; + &lt;kbd&gt;ww&lt;/kbd&gt;&lt;/td&gt;&lt;td&gt;在窗口间切换&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;kbd&gt;Ctrl&lt;/kbd&gt; + &lt;kbd&gt;wq&lt;/kbd&gt;&lt;/td&gt;&lt;td&gt;关闭窗口&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;kbd&gt;Ctrl&lt;/kbd&gt; + &lt;kbd&gt;wx&lt;/kbd&gt;&lt;/td&gt;&lt;td&gt;切换到下一个窗口&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;kbd&gt;Ctrl&lt;/kbd&gt; + &lt;kbd&gt;w=&lt;/kbd&gt;&lt;/td&gt;&lt;td&gt;让每个窗口具有相同高度和宽度&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;kbd&gt;Ctrl&lt;/kbd&gt; + &lt;kbd&gt;wh&lt;/kbd&gt;&lt;/td&gt;&lt;td&gt;切换到左侧窗口&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;kbd&gt;Ctrl&lt;/kbd&gt; + &lt;kbd&gt;wl&lt;/kbd&gt;&lt;/td&gt;&lt;td&gt;切换到右侧窗口&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;kbd&gt;Ctrl&lt;/kbd&gt; + &lt;kbd&gt;wj&lt;/kbd&gt;&lt;/td&gt;&lt;td&gt;切换到下侧窗口&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;kbd&gt;Ctrl&lt;/kbd&gt; + &lt;kbd&gt;wk&lt;/kbd&gt;&lt;/td&gt;&lt;td&gt;切换到上侧窗口&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;
&lt;h2 id=&#34;多文件搜索&#34;&gt;多文件搜索&lt;/h2&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th width=&#34;30%&#34;&gt;命令 / 快捷键&lt;/th&gt;&lt;th&gt;功能描述&lt;/th&gt;&lt;/tr&gt;&lt;/thead&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;&lt;kbd&gt;:vim[grep] /pattern/ {`{file}`}&lt;/kbd&gt;&lt;/td&gt;&lt;td&gt;在多个文件中搜索 &lt;code&gt;pattern&lt;/code&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;kbd&gt;:cn[ext]&lt;/kbd&gt;&lt;/td&gt;&lt;td&gt;移动至下一个搜索结果&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;kbd&gt;:cp[revious]&lt;/kbd&gt;&lt;/td&gt;&lt;td&gt;移动至上一个搜索结果&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;kbd&gt;:cope[n]&lt;/kbd&gt;&lt;/td&gt;&lt;td&gt;打开搜索结果列表&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;kbd&gt;:ccl[ose]&lt;/kbd&gt;&lt;/td&gt;&lt;td&gt;关闭 quickfix 窗口&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;
&lt;h2 id=&#34;标签&#34;&gt;标签&lt;/h2&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th width=&#34;30%&#34;&gt;命令 / 快捷键&lt;/th&gt;&lt;th&gt;功能描述&lt;/th&gt;&lt;/tr&gt;&lt;/thead&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;&lt;kbd&gt;:tabnew&lt;/kbd&gt; 或 &lt;kbd&gt;tabnew {page.words.file}&lt;/kbd&gt;&lt;/td&gt;&lt;td&gt;在新标签中打开文件&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;kbd&gt;Ctrl&lt;/kbd&gt; + &lt;kbd&gt;wT&lt;/kbd&gt;&lt;/td&gt;&lt;td&gt;将窗口编程标签&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;kbd&gt;gt&lt;/kbd&gt; 或 &lt;kbd&gt;:tabn[ext]&lt;/kbd&gt;&lt;/td&gt;&lt;td&gt;切换到下一个标签&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;kbd&gt;gT&lt;/kbd&gt; 或 &lt;kbd&gt;:tabp[revious]&lt;/kbd&gt;&lt;/td&gt;&lt;td&gt;切换到上一个标签&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;kbd&gt;2gt&lt;/kbd&gt;&lt;/td&gt;&lt;td&gt;切换到第 2 个标签&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;kbd&gt;:tabm[ove] 2&lt;/kbd&gt;&lt;/td&gt;&lt;td&gt;把当前标签移动到第 2 个位置（下表从 0 开始）&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;kbd&gt;tabc[lose]&lt;/kbd&gt;&lt;/td&gt;&lt;td&gt;关闭当前标签&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;kbd&gt;:tabo[nly]&lt;/kbd&gt;&lt;/td&gt;&lt;td&gt;关闭其他标签&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;kbd&gt;:tabdo command&lt;/kbd&gt;&lt;/td&gt;&lt;td&gt;在所有标签中执行指定的命令（如：使用 &lt;kbd&gt;tabdo q&lt;/kbd&gt; 关闭所有标签）&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;
&lt;h2 id=&#34;diff文件比较&#34;&gt;Diff（文件比较）&lt;/h2&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th width=&#34;30%&#34;&gt;命令 / 快捷键&lt;/th&gt;&lt;th&gt;功能描述&lt;/th&gt;&lt;/tr&gt;&lt;/thead&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;&lt;kbd&gt;zf&lt;/kbd&gt;&lt;/td&gt;&lt;td&gt;手动定义一个折迭行为&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;kbd&gt;zd&lt;/kbd&gt;&lt;/td&gt;&lt;td&gt;删除光标处的折迭&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;kbd&gt;za&lt;/kbd&gt;&lt;/td&gt;&lt;td&gt;展开 / 收起光标处的区块&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;kbd&gt;zo&lt;/kbd&gt;&lt;/td&gt;&lt;td&gt;展开光标处的区块&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;kbd&gt;zc&lt;/kbd&gt;&lt;/td&gt;&lt;td&gt;折迭光标处的区块&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;kbd&gt;zr&lt;/kbd&gt;&lt;/td&gt;&lt;td&gt;展开当前折迭层级&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;kbd&gt;zm&lt;/kbd&gt;&lt;/td&gt;&lt;td&gt;收起当前折迭层级&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;kbd&gt;zi&lt;/kbd&gt;&lt;/td&gt;&lt;td&gt;切换折迭功能&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;kbd&gt;]c&lt;/kbd&gt;&lt;/td&gt;&lt;td&gt;跳转到下一个不同处&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;kbd&gt;[c&lt;/kbd&gt;&lt;/td&gt;&lt;td&gt;跳转到上一个不同处&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;kbd&gt;do&lt;/kbd&gt; 或 &lt;kbd&gt;:diffg[et]&lt;/kbd&gt;&lt;/td&gt;&lt;td&gt;从其他缓冲区获取不同之处&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;kbd&gt;dp&lt;/kbd&gt; 或 &lt;kbd&gt;:diffpu[t]&lt;/kbd&gt;&lt;/td&gt;&lt;td&gt;把不同之处存入其他缓冲区&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;kbd&gt;:diffthis&lt;/kbd&gt;&lt;/td&gt;&lt;td&gt;把当前窗口的内容作为文件对比的一部分&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;kbd&gt;:dif[fupdate]&lt;/kbd&gt;&lt;/td&gt;&lt;td&gt;刷新，重新比较&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;kbd&gt;:diffo[ff]&lt;/kbd&gt;&lt;/td&gt;&lt;td&gt;关闭当前窗口的 Diff 模式&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;
&lt;h2 id=&#34;退出&#34;&gt;退出&lt;/h2&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th width=&#34;30%&#34;&gt;命令 / 快捷键&lt;/th&gt;&lt;th&gt;功能描述&lt;/th&gt;&lt;/tr&gt;&lt;/thead&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;&lt;kbd&gt;:w&lt;/kbd&gt;&lt;/td&gt;&lt;td&gt;保存&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;kbd&gt;:w !sudo tee %&lt;/kbd&gt;&lt;/td&gt;&lt;td&gt;使用 &lt;code&gt;sudo&lt;/code&gt; 保存当前文件&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;kbd&gt;:wq&lt;/kbd&gt; 或 &lt;kbd&gt;:x&lt;/kbd&gt; 或 &lt;kbd&gt;ZZ&lt;/kbd&gt;&lt;/td&gt;&lt;td&gt;保存并退出&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;kbd&gt;:q&lt;/kbd&gt;&lt;/td&gt;&lt;td&gt;退出（文件已修改且未保存时 Vim 将发出警告）&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;kbd&gt;:q!&lt;/kbd&gt; 或 &lt;kbd&gt;ZQ&lt;/kbd&gt;&lt;/td&gt;&lt;td&gt;强制退出（即使文件未保存）&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;kbd&gt;:wqa&lt;/kbd&gt;&lt;/td&gt;&lt;td&gt;保存所有标签页，并全部退出&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;- https://shenyiminghfut.github.io/posts/vim-%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E9%80%9F%E6%9F%A5/ - This is a customized copyright.</description>
        </item>
    
    
    
        <item>
        <title>Tmux教程</title>
        <link>https://shenyiminghfut.github.io/posts/tmux-%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/</link>
        <pubDate>Mon, 09 Mar 2020 10:58:08 -0400</pubDate>
        
        <guid>https://shenyiminghfut.github.io/posts/tmux-%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/</guid>
        <description>摆人日寄 https://shenyiminghfut.github.io/posts/tmux-%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/ -&lt;p&gt;Tmux 是一个终端复用器（terminal multiplexer），非常有用，属于常用的开发工具。&lt;/p&gt;
&lt;p&gt;本文介绍如何使用 Tmux。&lt;/p&gt;
&lt;h2 id=&#34;一tmux-是什么&#34;&gt;一、Tmux 是什么？&lt;/h2&gt;
&lt;h3 id=&#34;11-会话与进程&#34;&gt;1.1 会话与进程&lt;/h3&gt;
&lt;p&gt;命令行的典型使用方式是，打开一个终端窗口（terminal window，以下简称 &amp;ldquo;窗口&amp;rdquo;），在里面输入命令。&lt;strong&gt;用户与计算机的这种临时的交互，称为一次 &amp;ldquo;会话&amp;rdquo;（session）&lt;/strong&gt; 。&lt;/p&gt;
&lt;p&gt;会话的一个重要特点是，窗口与其中启动的进程是&lt;a href=&#34;https://www.ruanyifeng.com/blog/2016/02/linux-daemon.html&#34;&gt;连在一起&lt;/a&gt;的。打开窗口，会话开始；关闭窗口，会话结束，会话内部的进程也会随之终止，不管有没有运行完。&lt;/p&gt;
&lt;p&gt;一个典型的例子就是，&lt;a href=&#34;https://www.ruanyifeng.com/blog/2011/12/ssh_remote_login.html&#34;&gt;SSH 登录&lt;/a&gt;远程计算机，打开一个远程窗口执行命令。这时，网络突然断线，再次登录的时候，是找不回上一次执行的命令的。因为上一次 SSH 会话已经终止了，里面的进程也随之消失了。&lt;/p&gt;
&lt;p&gt;为了解决这个问题，会话与窗口可以 &amp;ldquo;解绑&amp;rdquo;：窗口关闭时，会话并不终止，而是继续运行，等到以后需要的时候，再让会话 &amp;ldquo;绑定&amp;rdquo; 其他窗口。&lt;/p&gt;
&lt;h3 id=&#34;12-tmux-的作用&#34;&gt;1.2 Tmux 的作用&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;Tmux 就是会话与窗口的 &amp;ldquo;解绑&amp;rdquo; 工具，将它们彻底分离。&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;（1）它允许在单个窗口中，同时访问多个会话。这对于同时运行多个命令行程序很有用。&lt;/p&gt;
&lt;p&gt;（2） 它可以让新窗口 &amp;ldquo;接入&amp;rdquo; 已经存在的会话。&lt;/p&gt;
&lt;p&gt;（3）它允许每个会话有多个连接窗口，因此可以多人实时共享会话。&lt;/p&gt;
&lt;p&gt;（4）它还支持窗口任意的垂直和水平拆分。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;类似的终端复用器还有 GNU Screen。Tmux 与它功能相似，但是更易用，也更强大。&lt;/p&gt;
&lt;h2 id=&#34;二基本用法&#34;&gt;二、基本用法&lt;/h2&gt;
&lt;h3 id=&#34;21-安装&#34;&gt;2.1 安装&lt;/h3&gt;
&lt;p&gt;Tmux 一般需要自己安装。&lt;/p&gt;
&lt;blockquote&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;# Ubuntu 或 Debian
$ sudo apt-get install tmux

# CentOS 或 Fedora
$ sudo yum install tmux

# Mac
$ brew install tmux
&lt;/code&gt;&lt;/pre&gt;&lt;/blockquote&gt;
&lt;h3 id=&#34;22-启动与退出&#34;&gt;2.2 启动与退出&lt;/h3&gt;
&lt;p&gt;安装完成后，键入&lt;code&gt;tmux&lt;/code&gt;命令，就进入了 Tmux 窗口。&lt;/p&gt;
&lt;blockquote&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;$ tmux
&lt;/code&gt;&lt;/pre&gt;&lt;/blockquote&gt;
&lt;p&gt;上面命令会启动 Tmux 窗口，底部有一个状态栏。状态栏的左侧是窗口信息（编号和名称），右侧是系统信息。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://www.wangbase.com/blogimg/asset/201910/bg2019102006.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;按下&lt;code&gt;Ctrl+d&lt;/code&gt;或者显式输入&lt;code&gt;exit&lt;/code&gt;命令，就可以退出 Tmux 窗口。&lt;/p&gt;
&lt;blockquote&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;$ exit
&lt;/code&gt;&lt;/pre&gt;&lt;/blockquote&gt;
&lt;h3 id=&#34;23-前缀键&#34;&gt;2.3 前缀键&lt;/h3&gt;
&lt;p&gt;Tmux 窗口有大量的快捷键。所有快捷键都要通过前缀键唤起。默认的前缀键是&lt;code&gt;Ctrl+b&lt;/code&gt;，即先按下&lt;code&gt;Ctrl+b&lt;/code&gt;，快捷键才会生效。&lt;/p&gt;
&lt;p&gt;举例来说，帮助命令的快捷键是&lt;code&gt;Ctrl+b ?&lt;/code&gt;。它的用法是，在 Tmux 窗口中，先按下&lt;code&gt;Ctrl+b&lt;/code&gt;，再按下&lt;code&gt;?&lt;/code&gt;，就会显示帮助信息。&lt;/p&gt;
&lt;p&gt;然后，按下 ESC 键或&lt;code&gt;q&lt;/code&gt;键，就可以退出帮助。&lt;/p&gt;
&lt;h2 id=&#34;三会话管理&#34;&gt;三、会话管理&lt;/h2&gt;
&lt;h3 id=&#34;31-新建会话&#34;&gt;3.1 新建会话&lt;/h3&gt;
&lt;p&gt;第一个启动的 Tmux 窗口，编号是&lt;code&gt;0&lt;/code&gt;，第二个窗口的编号是&lt;code&gt;1&lt;/code&gt;，以此类推。这些窗口对应的会话，就是 0 号会话、1 号会话。&lt;/p&gt;
&lt;p&gt;使用编号区分会话，不太直观，更好的方法是为会话起名。&lt;/p&gt;
&lt;blockquote&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;$ tmux new -s &amp;lt;session-name&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/blockquote&gt;
&lt;p&gt;上面命令新建一个指定名称的会话。&lt;/p&gt;
&lt;h3 id=&#34;32-分离会话&#34;&gt;3.2 分离会话&lt;/h3&gt;
&lt;p&gt;在 Tmux 窗口中，按下&lt;code&gt;Ctrl+b d&lt;/code&gt;或者输入&lt;code&gt;tmux detach&lt;/code&gt;命令，就会将当前会话与窗口分离。&lt;/p&gt;
&lt;blockquote&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;$ tmux detach
&lt;/code&gt;&lt;/pre&gt;&lt;/blockquote&gt;
&lt;p&gt;上面命令执行后，就会退出当前 Tmux 窗口，但是会话和里面的进程仍然在后台运行。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;tmux ls&lt;/code&gt;命令可以查看当前所有的 Tmux 会话。&lt;/p&gt;
&lt;blockquote&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;$ tmux ls
# or
$ tmux list-session
&lt;/code&gt;&lt;/pre&gt;&lt;/blockquote&gt;
&lt;h3 id=&#34;33-接入会话&#34;&gt;3.3 接入会话&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;tmux attach&lt;/code&gt;命令用于重新接入某个已存在的会话。&lt;/p&gt;
&lt;blockquote&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;# 使用会话编号
$ tmux attach -t 0

# 使用会话名称
$ tmux attach -t &amp;lt;session-name&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/blockquote&gt;
&lt;h3 id=&#34;34-杀死会话&#34;&gt;3.4 杀死会话&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;tmux kill-session&lt;/code&gt;命令用于杀死某个会话。&lt;/p&gt;
&lt;blockquote&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;# 使用会话编号
$ tmux kill-session -t 0

# 使用会话名称
$ tmux kill-session -t &amp;lt;session-name&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/blockquote&gt;
&lt;h3 id=&#34;35-切换会话&#34;&gt;3.5 切换会话&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;tmux switch&lt;/code&gt;命令用于切换会话。&lt;/p&gt;
&lt;blockquote&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;# 使用会话编号
$ tmux switch -t 0

# 使用会话名称
$ tmux switch -t &amp;lt;session-name&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/blockquote&gt;
&lt;h3 id=&#34;36-重命名会话&#34;&gt;3.6 重命名会话&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;tmux rename-session&lt;/code&gt;命令用于重命名会话。&lt;/p&gt;
&lt;blockquote&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;$ tmux rename-session -t 0 &amp;lt;new-name&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/blockquote&gt;
&lt;p&gt;上面命令将 0 号会话重命名。&lt;/p&gt;
&lt;h3 id=&#34;37-会话快捷键&#34;&gt;3.7 会话快捷键&lt;/h3&gt;
&lt;p&gt;下面是一些会话相关的快捷键。&lt;/p&gt;
&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;Ctrl+b d&lt;/code&gt;：分离当前会话。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Ctrl+b s&lt;/code&gt;：列出所有会话。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Ctrl+b $&lt;/code&gt;：重命名当前会话。&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;四最简操作流程&#34;&gt;四、最简操作流程&lt;/h2&gt;
&lt;p&gt;综上所述，以下是 Tmux 的最简操作流程。&lt;/p&gt;
&lt;blockquote&gt;
&lt;ol&gt;
&lt;li&gt;新建会话&lt;code&gt;tmux new -s my_session&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;在 Tmux 窗口运行所需的程序。&lt;/li&gt;
&lt;li&gt;按下快捷键&lt;code&gt;Ctrl+b d&lt;/code&gt;将会话分离。&lt;/li&gt;
&lt;li&gt;下次使用时，重新连接到会话&lt;code&gt;tmux attach-session -t my_session&lt;/code&gt;。&lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;五窗格操作&#34;&gt;五、窗格操作&lt;/h2&gt;
&lt;p&gt;Tmux 可以将窗口分成多个窗格（pane），每个窗格运行不同的命令。以下命令都是在 Tmux 窗口中执行。&lt;/p&gt;
&lt;h3 id=&#34;51-划分窗格&#34;&gt;5.1 划分窗格&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;tmux split-window&lt;/code&gt;命令用来划分窗格。&lt;/p&gt;
&lt;blockquote&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;# 划分上下两个窗格
$ tmux split-window

# 划分左右两个窗格
$ tmux split-window -h
&lt;/code&gt;&lt;/pre&gt;&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&#34;https://www.wangbase.com/blogimg/asset/201910/bg2019102007.jpg&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;52-移动光标&#34;&gt;5.2 移动光标&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;tmux select-pane&lt;/code&gt;命令用来移动光标位置。&lt;/p&gt;
&lt;blockquote&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;# 光标切换到上方窗格
$ tmux select-pane -U

# 光标切换到下方窗格
$ tmux select-pane -D

# 光标切换到左边窗格
$ tmux select-pane -L

# 光标切换到右边窗格
$ tmux select-pane -R
&lt;/code&gt;&lt;/pre&gt;&lt;/blockquote&gt;
&lt;h3 id=&#34;53-交换窗格位置&#34;&gt;5.3 交换窗格位置&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;tmux swap-pane&lt;/code&gt;命令用来交换窗格位置。&lt;/p&gt;
&lt;blockquote&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;# 当前窗格上移
$ tmux swap-pane -U

# 当前窗格下移
$ tmux swap-pane -D
&lt;/code&gt;&lt;/pre&gt;&lt;/blockquote&gt;
&lt;h3 id=&#34;54-窗格快捷键&#34;&gt;5.4 窗格快捷键&lt;/h3&gt;
&lt;p&gt;下面是一些窗格操作的快捷键。&lt;/p&gt;
&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;Ctrl+b %&lt;/code&gt;：划分左右两个窗格。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Ctrl+b &amp;quot;&lt;/code&gt;：划分上下两个窗格。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Ctrl+b &amp;lt;arrow key&amp;gt;&lt;/code&gt;：光标切换到其他窗格。&lt;code&gt;&amp;lt;arrow key&amp;gt;&lt;/code&gt;是指向要切换到的窗格的方向键，比如切换到下方窗格，就按方向键&lt;code&gt;↓&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Ctrl+b ;&lt;/code&gt;：光标切换到上一个窗格。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Ctrl+b o&lt;/code&gt;：光标切换到下一个窗格。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Ctrl+b {&lt;/code&gt;：当前窗格与上一个窗格交换位置。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Ctrl+b }&lt;/code&gt;：当前窗格与下一个窗格交换位置。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Ctrl+b Ctrl+o&lt;/code&gt;：所有窗格向前移动一个位置，第一个窗格变成最后一个窗格。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Ctrl+b Alt+o&lt;/code&gt;：所有窗格向后移动一个位置，最后一个窗格变成第一个窗格。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Ctrl+b x&lt;/code&gt;：关闭当前窗格。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Ctrl+b !&lt;/code&gt;：将当前窗格拆分为一个独立窗口。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Ctrl+b z&lt;/code&gt;：当前窗格全屏显示，再使用一次会变回原来大小。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Ctrl+b Ctrl+&amp;lt;arrow key&amp;gt;&lt;/code&gt;：按箭头方向调整窗格大小。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Ctrl+b q&lt;/code&gt;：显示窗格编号。&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;六窗口管理&#34;&gt;六、窗口管理&lt;/h2&gt;
&lt;p&gt;除了将一个窗口划分成多个窗格，Tmux 也允许新建多个窗口。&lt;/p&gt;
&lt;h3 id=&#34;61-新建窗口&#34;&gt;6.1 新建窗口&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;tmux new-window&lt;/code&gt;命令用来创建新窗口。&lt;/p&gt;
&lt;blockquote&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;$ tmux new-window

# 新建一个指定名称的窗口
$ tmux new-window -n &amp;lt;window-name&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/blockquote&gt;
&lt;h3 id=&#34;62-切换窗口&#34;&gt;6.2 切换窗口&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;tmux select-window&lt;/code&gt;命令用来切换窗口。&lt;/p&gt;
&lt;blockquote&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;# 切换到指定编号的窗口
$ tmux select-window -t &amp;lt;window-number&amp;gt;

# 切换到指定名称的窗口
$ tmux select-window -t &amp;lt;window-name&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/blockquote&gt;
&lt;h3 id=&#34;63-重命名窗口&#34;&gt;6.3 重命名窗口&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;tmux rename-window&lt;/code&gt;命令用于为当前窗口起名（或重命名）。&lt;/p&gt;
&lt;blockquote&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;$ tmux rename-window &amp;lt;new-name&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/blockquote&gt;
&lt;h3 id=&#34;64-窗口快捷键&#34;&gt;6.4 窗口快捷键&lt;/h3&gt;
&lt;p&gt;下面是一些窗口操作的快捷键。&lt;/p&gt;
&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;Ctrl+b c&lt;/code&gt;：创建一个新窗口，状态栏会显示多个窗口的信息。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Ctrl+b p&lt;/code&gt;：切换到上一个窗口（按照状态栏上的顺序）。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Ctrl+b n&lt;/code&gt;：切换到下一个窗口。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Ctrl+b &amp;lt;number&amp;gt;&lt;/code&gt;：切换到指定编号的窗口，其中的&lt;code&gt;&amp;lt;number&amp;gt;&lt;/code&gt;是状态栏上的窗口编号。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Ctrl+b w&lt;/code&gt;：从列表中选择窗口。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Ctrl+b ,&lt;/code&gt;：窗口重命名。&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;七其他命令&#34;&gt;七、其他命令&lt;/h2&gt;
&lt;p&gt;下面是一些其他命令。&lt;/p&gt;
&lt;blockquote&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;# 列出所有快捷键，及其对应的 Tmux 命令
$ tmux list-keys

# 列出所有 Tmux 命令及其参数
$ tmux list-commands

# 列出当前所有 Tmux 会话的信息
$ tmux info

# 重新加载当前的 Tmux 配置
$ tmux source-file ~/.tmux.conf
&lt;/code&gt;&lt;/pre&gt;&lt;/blockquote&gt;
&lt;h2 id=&#34;八参考链接&#34;&gt;八、参考链接&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://www.hamvocke.com/blog/a-quick-and-easy-guide-to-tmux/&#34;&gt;A Quick and Easy Guide to tmux&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://danielmiessler.com/study/tmux/&#34;&gt;Tactical tmux: The 10 Most Important Commands&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://linuxize.com/post/getting-started-with-tmux/&#34;&gt;Getting started with Tmux&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
- https://shenyiminghfut.github.io/posts/tmux-%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/ - This is a customized copyright.</description>
        </item>
    
    
    
        <item>
        <title>socat&amp;&amp;netcat最佳实践.</title>
        <link>https://shenyiminghfut.github.io/posts/-socat-netcat/</link>
        <pubDate>Thu, 14 Nov 2019 11:25:05 -0400</pubDate>
        
        <guid>https://shenyiminghfut.github.io/posts/-socat-netcat/</guid>
        <description>摆人日寄 https://shenyiminghfut.github.io/posts/-socat-netcat/ -&lt;blockquote&gt;
&lt;p&gt;文中的命令均在 macOS Big Sur 和 openSUSE Tumbleweed 上测试通过&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;netcat(network cat) 是一个历史悠久的网络工具包，被称作 TCP/IP 的瑞士军刀，各大 Linux 发行版都有默认安装 openbsd 版本的 netcat，它的命令行名称为 &lt;code&gt;nc&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;而 socat(socket cat)，官方文档描述它是 &lt;code&gt;&amp;quot;netcat++&amp;quot; (extended design, new implementation)&lt;/code&gt;，项目比较活跃，kubernetes-client(kubectl) 底层就是使用的它做各种流量转发。&lt;/p&gt;
&lt;p&gt;在不方便安装 socat 的环境中，我们可以使用系统自带的 netcat. 而在其他环境，可以考虑优先使用 socat.&lt;/p&gt;
&lt;p&gt;socat 的基本命令格式：&lt;/p&gt;
&lt;p&gt;给 socat 提供两个地址，socat 干的活就是把两个地址的流对接起来。左边地址的输出传给右边，同时又把右边地址的输出传给左边，也就是一个&lt;strong&gt;双向的数据管道&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;听起来好像没啥特别的，但是实际上计算机网络干的活也就是数据传输而已，却影响了整个世界，不可小觑它的功能。&lt;/p&gt;
&lt;p&gt;socat 支持非常多的地址类型：&lt;code&gt;-&lt;/code&gt;/stdio，TCP, TCP-LISTEN, UDP, UDP-LISTEN, OPEN, EXEC, SOCKS, PROXY 等等，可用于端口监听、链接，文件和进程读写，代理桥接等等。&lt;/p&gt;
&lt;p&gt;socat 的功能就是这么简单，命令行参数也很简洁，唯一需要花点精力学习的就是它各种地址的定义和搭配写法。
·
而 netcat 定义貌似没这么严谨，可以简单的理解为网络版的 cat 命令 2333&lt;/p&gt;
&lt;p&gt;各发行版都自带 netcat，包名通常为 &lt;code&gt;nc-openbsd&lt;/code&gt;，因此这里只介绍 socat 的安装方法：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;# Debian/Ubuntu
sudo apt install socat

# CentOS/RedHat
sudo yum install socat

# macOS
brew install socat
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;其他发行版基本也都可以使用包管理器安装 socat&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;以前你可能学过如何用 telnet 来做这项测试，不过现在很多发行版基本都不自带 telnet 了，还需要额外安装。 telnet 差不多已经快寿终正寝了，还是建议使用更专业的 socat/netcat&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;使用 socat/netcat 检测远程端口的可连接性：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;# -d[ddd] 增加日志详细程度，-dd  Prints fatal, error, warning, and notice messages.
socat -dd - TCP:192.168.1.252:3306

# -v 显示详细信息
# -z 不发送数据，效果为立即关闭连接，快速得出结果
nc -vz 192.168.1.2 8080

# -vv 显示更详细的内容
# -w2 超时时间设为 2 秒
# 使用 nc 做简单的端口扫描
nc -vv -w2 -z 192.168.1.2 20-500
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;在本机监听一个 TCP 端口，接收到的内容传到 stdout，同时将 stdin 的输入传给客户端：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;# 服务端启动命令，socat/nc 二选一
socat TCP-LISTEN:7000 -
# -l --listening
nc -l 7000
# 当然也可以使用 python3（注意文件安全性）
# 此命令在 7000 端口启用一个文件服务器，绑定到 0.0.0.0，以当前目录为根目录
python3 -m http.server 7000
# 或者在较老的机器上可以用 python2（注意文件安全性）
python -m SimpleHTTPServer 8000

# 客户端连接命令，socat/nc 二选一
socat TCP:192.168.31.123:7000 -
nc 192.168.11.123 7000
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;UDP 协议的测试也非常类似，使用 netcat 的示例如下：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;# 服务端，只监听 ipv4
nc -u -l 8080

# 客户端
nc -u 192.168.31.123 8080
# 客户端本机测试，注意 localhost 会被优先解析为 ipv6! 这会导致服务端(ipv4)的 nc 接收不到数据！
nc -u localhost 8080
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;使用 socat 的 UDP 测试示例如下：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;socat UDP-LISTEN:7000 -

socat UDP:192.168.31.123:7000 -
&lt;/code&gt;&lt;/pre&gt;&lt;blockquote&gt;
&lt;p&gt;参考 socat 官方文档：&lt;a href=&#34;http://www.dest-unreach.org/socat/doc/socat-openssltunnel.html&#34;&gt;Securing Traffic Between two Socat Instances Using SSL&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;测试证书及私钥的生成参见 &lt;a href=&#34;https://thiscute.world/posts/about-tls-cert/&#34;&gt;写给开发人员的实用密码学（八）—— 数字证书与 TLS 协议&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;模拟一个 mTLS 服务器，监听 4433 端口，接收到的数据同样输出到 stdout：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;# socat 需要使用同时包含证书和私钥的 pem 文件，生成方法如下
cat server.key server.crt &amp;gt; server.pem
cat client.key client.crt &amp;gt; client.pem

# 服务端启动命令
socat openssl-listen:4433,reuseaddr,cert=server.pem,cafile=client.crt -

# 客户端连接命令（使用系统的 ca.crt 或者你自己的私有 ca.cert 来验证服务端证书）
socat - openssl-connect:192.168.31.123:4433,cert=client.pem,cafile=ca.crt
# 或者使用 curl 连接（ca.crt 证书来源同上）
curl -v --cacert ca.crt --cert client.crt --key client.key --tls-max 1.2 https://192.168.31.123:4433
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;上面的命令使用了 mTLS 双向认证的协议，可通过设定 &lt;code&gt;verify=0&lt;/code&gt; 来关掉客户端认证，示例如下：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;# socat 需要使用同时包含证书和私钥的 pem 文件，生成方法如下
cat server.key server.crt &amp;gt; server.pem

# 服务端启动命令
socat openssl-listen:4433,reuseaddr,cert=server.pem,verify=0 -

# 客户端连接命令，如果 ip/域名不受证书保护，就也需要添加 verify=0
# （使用系统的 ca.crt 或者你自己的私有 ca.cert 来验证服务端证书）
socat - openssl-connect:192.168.31.123:4433,cafile=ca.crt
# 或者使用 curl 连接（ca.crt 证书来源同上）
curl -v --cacert ca.crt https://192.168.31.123:4433
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;通常传输文件时，我都习惯使用 scp/ssh/rsync，但是 socat 其实也可以传输文件。&lt;/p&gt;
&lt;p&gt;以将 demo.tar.gz 从主机 A 发送到主机 B 为例， 首先在数据发送方 A 执行如下命令：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;# -u 表示数据只从左边的地址单向传输给右边（socat 默认是一个双向管道）
# -U 和 -u 相反，数据只从右边单向传输给左边
socat -u open:demo.tar.gz tcp-listen:2000,reuseaddr
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;然后在数据接收方 B 执行如下命令，就能把文件接收到：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;socat -u tcp:192.168.1.252:2000 open:demo.tar.gz,create
# 如果觉得太繁琐，也可以直接通过 stdout 重定向
socat -u tcp:192.168.1.252:2000 - &amp;gt; demo.tar.gz
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;使用 netcat 也可以实现数据传输：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;# 先在接收方启动服务端
nc -l -p 8080 &amp;gt; demo.tar.gz
# 再在发送方启动客户端发送数据
nc 192.168.1.2 8080 &amp;lt; demo.tar.gz
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;使用 &lt;code&gt;fork&lt;/code&gt; &lt;code&gt;reuseaddr&lt;/code&gt; &lt;code&gt;SYSTEM&lt;/code&gt; 三个命令，再用 &lt;code&gt;systemd&lt;/code&gt;/&lt;code&gt;supervisor&lt;/code&gt; 管理一下，就可以用几行命令实现一个简单的后台服务器。&lt;/p&gt;
&lt;p&gt;下面的命令将监听 8080 端口，并将数据流和 web.py 的 stdio 连接起来，可以直接使用浏览器访问 &lt;code&gt;http://&amp;lt;ip&amp;gt;:8080&lt;/code&gt; 来查看效果。&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;socat TCP-LISTEN:8080,reuseaddr,fork SYSTEM:&amp;#34;python3 web.py&amp;#34;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;假设 &lt;code&gt;web.py&lt;/code&gt; 的内容为：&lt;/p&gt;
&lt;p&gt;那 &lt;code&gt;curl localhost:8080&lt;/code&gt; 就应该会输出 &lt;code&gt;hello world&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;当然，如果你仅希望快速提供一个文件服务器，也可直接使用 python 命令：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;# https://docs.python.org/3/library/http.server.html#http.server.SimpleHTTPRequestHandler.do_GET
python3 -m http.server 8000 --directory /tmp/

# 或者在旧机器上可以直接使用 python2 提供文件服务器，默认以当前文件夹为根目录
python -m SimpleHTTPServer 8000
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;监听 8080 端口，建立该端口与 &lt;code&gt;baidu.com:80&lt;/code&gt; 之间的双向管道:&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;socat TCP-LISTEN:8080,fork,reuseaddr  TCP:baidu.com:80
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;拿 curl 命令测试一下，应该能正常访问到百度：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;# 注意指定 Host
curl -v -H &amp;#39;Host: baidu.com&amp;#39; localhost:8080
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;其他用法，比如为一个仅监听了 &lt;code&gt;127.0.0.1&lt;/code&gt; loopback 网卡的服务，允许通过外部网络访问（注意安全性）：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;socat TCP-LISTEN:5432,fork,reuseaddr  TCP:localhost:3658
&lt;/code&gt;&lt;/pre&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://zhuanlan.zhihu.com/p/347722248&#34;&gt;新版瑞士军刀：socat - 韦易笑 - 知乎&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://zhuanlan.zhihu.com/p/83959309&#34;&gt;用好你的瑞士军刀 / netcat - 韦易笑 - 知乎&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.dest-unreach.org/socat/&#34;&gt;socat - Multipurpose relay&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
- https://shenyiminghfut.github.io/posts/-socat-netcat/ - This is a customized copyright.</description>
        </item>
    
    
    
        <item>
        <title>ssh端口转发</title>
        <link>https://shenyiminghfut.github.io/posts/%E5%BD%BB%E5%BA%95%E6%90%9E%E6%87%82-ssh-%E7%AB%AF%E5%8F%A3%E8%BD%AC%E5%8F%91%E5%91%BD%E4%BB%A4/</link>
        <pubDate>Thu, 14 Nov 2019 11:25:05 -0400</pubDate>
        
        <guid>https://shenyiminghfut.github.io/posts/%E5%BD%BB%E5%BA%95%E6%90%9E%E6%87%82-ssh-%E7%AB%AF%E5%8F%A3%E8%BD%AC%E5%8F%91%E5%91%BD%E4%BB%A4/</guid>
        <description>摆人日寄 https://shenyiminghfut.github.io/posts/%E5%BD%BB%E5%BA%95%E6%90%9E%E6%87%82-ssh-%E7%AB%AF%E5%8F%A3%E8%BD%AC%E5%8F%91%E5%91%BD%E4%BB%A4/ -&lt;p&gt;SSH 端口转发（隧道）功能强大、用途广泛，仅仅一行代码便可以将两台主机联系起来，对特定的访问请求进行代理。正确书写 SSH 命令是实现一切的基础。然而许多关于端口转发命令参数的介绍都是浅入深出：罗列名词却不加解释，给出实例却不讲如何举一反三。因而在此尝试整理一份更清晰的使用指引，不涉及原理。不足之处欢迎评论区交流。&lt;/p&gt;
&lt;h2 id=&#34;一基本连接&#34;&gt;一　基本连接&lt;/h2&gt;
&lt;p&gt;SSH 基本的连接命令是：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;ssh username@hostname
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;这里牵扯到了两台主机，一是执行命令、运行 SSH 客户端的主机，我们称为本地主机 A【Host A】；二是接收连接请求、运行 SSH 服务器的主机，我们称为远程主机 B【Host B】。通过密码或密钥等方式验证后，SSH 连接建立，主机 A 可以使用命令行对主机 B 实施远程控制。&lt;/p&gt;
&lt;p&gt;以上命令中，username 是主机 B 上已登录的用户名，hostname 则是主机 B 的设备名、域名或 IP 等可以在网络（局域网或互联网）上定位的名称。&lt;/p&gt;
&lt;p&gt;端口转发涉及的主机较多，这是引起名词混乱的原因之一。在此不深究用词问题，仅以字母代表之。如无特殊说明，SSH 连接都建立在由主机 A 到主机 B 间，SSH 命令都在主机 A 上被执行。&lt;/p&gt;
&lt;h2 id=&#34;二本地端口转发&#34;&gt;二　本地端口转发&lt;/h2&gt;
&lt;p&gt;顾名思义，本地端口转发是将应用【application client】对于本地主机 A 指定端口 X 的访问请求转发给主机 B，交由主机 B 对另一指定主机 C 的指定端口 Z 发起访问。命令如下：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;ssh -L 主机A端口X:主机C:主机C端口Z username@hostname
# 简单理解为：将对A:X的访问转变成对C:Z的访问
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;客户端在执行端口转发命令的同时，实际上也执行了基本的连接命令。多出来的部分中，「-L」旗标表示使用「本地端口转发」选项，之后是用冒号分隔开的三个需要指定的项。原理上，主机 C 可以是任何能够被主机 B 识别到的设备，也可以是主机 B 自身。&lt;/p&gt;
&lt;p&gt;当主机 C 在其某端口提供某服务【application server】，主机 A 需要使用该服务却无法直接访问主机 C 或该端口时，如果发现有 SSH：A→B 的连接，且主机 B 能够直接访问主机 C 的该端口，本地端口转发就派上用场。&lt;/p&gt;
&lt;p&gt;此时，访问请求在主机 A 一侧发生，可以来自于主机 A 自身，也可以是其他与 A 连接的设备。图中 Host A 或 Host B 的阴影指代主机 A 或主机 B 一侧的网络系统。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;补充说明&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;实际上 ssh 本地端口转发命令的「-L」旗标后可以填写四个参数，完整格式为：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;ssh -L [收听接口:]收听端口:目标主机:目标端口 username@hostname
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;命令中方括号内的部分，即第一个参数可以不写；它的默认值一般是 0.0.0.0（OpenSSH 客户端配置文件「ssh_config」中「GatewayPorts」选项的值一般为「yes」），意味着 SSH 隧道会收听所有接口，接受来自任何地址的应用访问请求并进行转发。而如果在此处填写了绑定地址（bind address），SSH 隧道连接就会只处理来自绑定地址的应用请求，而对其他地址发来的请求置之不理；如同在（真实世界的）隧道入口设立哨卡，只对白名单牌号的车辆放行。例如在此处填写 127.0.0.1，即可实现只有来自主机 A 本机的应用请求才被 SSH 隧道转发的效果。&lt;/p&gt;
&lt;p&gt;需留意，收听接口是站在主机 A 的视角上去规定允许与 A 连接的设备，解决「能够使用 SSH 端口转发的应用请求从何处来」的问题，类似防火墙的入站；收听端口则依旧是主机 A 上的那个端口 X，不能够跑到别的主机上去。&lt;/p&gt;
&lt;p&gt;类似地，远程端口转发和动态端口转发也具有「收听接口」这一可不指明的参数，下文不再赘述。从安全或控制流量的角度，规定绑定地址是一项实用的功能。&lt;/p&gt;
&lt;h3 id=&#34;场景&#34;&gt;场景①&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;主机 B 与主机 C 处于同一内网中，主机 B 能够与外界联系而主机 C 不能。这时不处于内网中的主机 A 如果想要访问主机 C，就可以通过 SSH 连接主机 B＋端口转发来进行。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;台式机 B 上运行着虚拟机 C，虚拟机使用虚拟机软件搭建的虚拟网络与宿主主机 B 相连接，但在主机 B 以外无法直接访问该虚拟网络。想要通过 SSH，用与台式机 B 处于同一 WiFi 下的笔记本 A 来远程控制虚拟机 C，（在 A 上）执行端口转发命令：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;ssh -L 22022:10.0.2.15:22 desktop_user@192.168.1.11	# cmd.1-1
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;其中，22022 号端口是随便选的一个没被占用的端口；192.168.1.11 是台式机 B 在 WiFi 中的 IP；desktop_user 是主机 B 上的用户名；10.0.2.15 是虚拟机 C 在主机 B 为其搭建的虚拟网络中的 IP；22 号端口是默认的 SSH 端口。已知 virtual_user 是虚拟机 C 上的用户名，这时在笔记本 A 上执行应用的访问请求命令：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;ssh -p 22022 virtual_user@localhost	# cmd.1-2
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;我们在笔记本 A 上以 SSH 协议访问本机（localhost）的 22022 号端口，这个请求就像通过了隧道（SSH 隧道）一样抵达台式机 B，台式机 B 则把这个请求变为对虚拟机 C 的 22 号端口的访问，并为 A 返回结果。其中，使用「-p」旗标是为了访问主机 A 的特定端口而不是 SSH 默认的 22 号端口；由于我们在主机 A 上执行命令，A 管自己叫 localhost，假如在其他主机上执行则需相应地改为主机 A 的域名或 IP 等他们对 A 的称呼。&lt;/p&gt;
&lt;p&gt;cmd.1-2 中我们是将 SSH 当作普通应用使用的。参考 Fig.1，cmd.1-1 在 A 与 B 之间建立 SSH 隧道，此时 A 上的 SSH 客户端和 B 上的 SSH 服务器对应图中的 SSH Client 和 SSH Server；cmd.1-2 则表达应用的访问请求，此时 A 上的 SSH 客户端和 C 上的 SSH 服务器对应图中的 application client 和 application server。&lt;/p&gt;
&lt;p&gt;以上 cmd.1-1 和 cmd.1-2 合起来实际是想（在 A 上）进行：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;ssh -p 22 virtual_user@10.0.2.15	# cmd.1-3
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;当然，如果这 cmd.1-3 能被成功执行的话，就不需要端口转发了。&lt;/p&gt;
&lt;h3 id=&#34;场景-1&#34;&gt;场景②&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;防火墙阻止了主机 A 对主机 B 一些端口的连接，但主机 B 仍有部分端口是对主机 A 开放的。这时主机 A 如果需要访问主机 B 上被防火墙阻挡的端口，就可以通过 SSH 连接主机 B＋端口转发来进行。需注意，这时所谓的主机 C 就是主机 B。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;某某云的云服务器 B 默认的防火墙设置仅开放了 22 号端口，其他入方向的访问都被屏蔽了。我们为云服务器 B 安装了桌面环境，现在想要在自己的计算机 A 上，通过 VNC 远程控制云服务器 B 的桌面。（在 A 上）执行端口转发命令：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;ssh -L 5920:localhost:5901 cloud_user@server.example.com	# cmd.2-1
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;因为 C 就是 B 自己，所以 C 的位置填 localhost；5920 随便选；5901 是云服务器 B 上 VNC 服务进程收听的端口；cloud_user 是 B 上的用户名；http://server.example.com 是 B 的域名，换成公网 IP 也行。&lt;/p&gt;
&lt;p&gt;下面在计算机 A 上打开 RealVNC VNC Viewer（VNC 客户端），输入 VNC 服务器地址：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;localhost:20
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;20=5920−5900，这是采用 5901 到 5999 之间端口时 RealVNC 的特殊设定。开始使用优雅（或许吧）的 GUI 来操作云服务器吧！&lt;/p&gt;
&lt;h2 id=&#34;三远程端口转发&#34;&gt;三　远程端口转发&lt;/h2&gt;
&lt;p&gt;当主机 C 在其某端口提供某服务，主机 B 需要使用该服务却无法直接访问主机 C 或该端口时，如果发现有 SSH：A→B 的连接，且主机 A 能够直接访问主机 C 的该端口，远程端口转发就派上用场。&lt;/p&gt;
&lt;p&gt;需注意，此时访问请求在主机 B 一侧发生，而 SSH 连接的方向却没有变化，仍是由 A 到 B 的。因此「本地与远程端口转发互为镜像」的说法并不完全准确；严格意义上的镜像，SSH 连接也要变为由 B 到 A，那时则应该是在 B 上采用本地端口转发。可以看出，采取哪种端口转发主要取决于 SSH 连接建立的方向。&lt;/p&gt;
&lt;p&gt;与本地端口转发的流动方向相反，远程端口转发是将对于远程主机 B 指定端口 Y 的访问请求转发给主机 A，交由主机 A 对另一指定主机 C 的指定端口 Z 发起访问。命令如下：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;ssh -R 主机B端口Y:主机C:主机C端口Z username@hostname
# 简单理解为：将对B:Y的访问转变成对C:Z的访问
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;username@hostname 不变，因为我们仍然以从主机 A 对主机 B 发起 SSH 连接为基础；「-R」旗标表示使用「远程端口转发」选项，之后是用冒号分隔开的三个需要指定的项。原理上，主机 C 可以是任何能够被主机 A 识别到的设备，也可以是主机 A 自身。&lt;/p&gt;
&lt;h3 id=&#34;场景-2&#34;&gt;场景③&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;主机 A 与主机 C 处于同一内网中，主机 A 能够与外界联系而主机 C 不能。这时（在主机 A 上）如果想让不处于内网中的主机 B 访问主机 C，就可以通过 SSH 连接主机 B＋端口转发来进行。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;台式机 A 上运行着虚拟机 C，虚拟机使用虚拟机软件搭建的虚拟网络与宿主主机 A 相连接，但在主机 A 以外无法直接访问该虚拟网络。想要通过 SFTP，用与台式机 A 处于同一 WiFi 下的笔记本 B 来向虚拟机 C 传输文件，（在 A 上）执行端口转发命令：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;ssh -R 22122:10.0.2.16:22 laptop_user@192.168.1.233	# cmd.3-1
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;其中，22122 号端口是随便选的一个没被占用的端口；192.168.1.233 是笔记本 B 在 WiFi 中的 IP；laptop_user 是主机 B 上的用户名；10.0.2.16 是虚拟机 C 在主机 A 为其搭建的虚拟网络中的 IP；22 号端口是默认的 SFTP 端口。已知 virtual_user 是虚拟机 C 上的用户名，这时在笔记本 B 上执行应用的访问请求命令：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;sftp -P 22122 virtual_user@localhost	# cmd.3-2
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;请注意这是一条运行在 B 上的应用命令；B 上的 SFTP 客户端这时充当 Fig.2 中的 application client。此处 localhost 是主机 B 对自己的称呼。对 B 的 22122 号端口的访问被转发至 A，A 访问 C，即 10.0.2.16 的 22 号端口并将结果返回给 B。于是 B 就通过远程端口转发成功访问了 C 上的 SFTP 服务器。&lt;/p&gt;
&lt;p&gt;以上 cmd.3-1 和 cmd.3-2 合起来实际是想（在 B 上）进行：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;sftp -P 22 virtual_user@10.0.2.15	# cmd.3-3
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;当然，这 cmd.3-3 也是不能被直接成功执行的。&lt;/p&gt;
&lt;h3 id=&#34;场景-3&#34;&gt;场景④&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;处于内网之中的主机 A 可以访问公网，但不具有公网 IP；公网中的主机 B 无法找到 A，但为 A 开放各个端口的访问（A 可以直接连接 B，反之则不行）。这时 A 想要让 B 访问自己，就可以通过 SSH 连接主机 B＋端口转发来进行。需注意，这时所谓的主机 C 就是主机 A。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;注意：OpenSSH 服务器对于远程端口转发的设定，默认只接受远程主机 B 本机上的应用发起的请求。想要从其他连接到 B 的设备发起请求，需将「sshd_config」文件中「GatewayPorts」选项后的「no」修改为「yes」。&lt;/p&gt;
&lt;p&gt;手头上计算机 A 运行着 http 服务，但 A 没有公网 IP，其他设备不能使用该服务。恰好云服务器 B 有公网 IP（甚至域名），便于被访问。在不将 http 服务迁移至云服务器 B 的前提下，可以使用 SSH 端口转发使其他设备通过访问 B 的方式访问 A 上的 http 服务。（在 A 上）执行端口转发命令：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;ssh -R 80:localhost:80 cloud_user@server.example.com	# cmd.4-1
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;这时 C 便是 A 自己（localhost）；80 号端口是 http 默认端口，为简便两个都用默认；cloud_user 还是 B 上的用户名；http://server.example.com 还是 B 的域名。&lt;/p&gt;
&lt;p&gt;接下来在其他设备上打开浏览器，输入地址：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;http://server.example.com/
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;于是大家可以通过访问 &lt;a href=&#34;http://server.example.com&#34;&gt;http://server.example.com&lt;/a&gt; 来访问本地计算机 A 提供的 http 服务了。&lt;/p&gt;
&lt;h2 id=&#34;四动态端口转发&#34;&gt;四　动态端口转发&lt;/h2&gt;
&lt;p&gt;动态端口转发可以把本地主机 A 上运行的 SSH 客户端转变成一个 SOCKS 代理服务器；实际上它是一种特殊的本地端口转发，或者说叫它「动态本地端口转发」更科学。这个动态，就动在这种转发不规定目标地址（主机 C）和目标端口（端口 Z），而是去读取应用发起的请求，从请求中获取目标信息。&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;ssh -D 主机A端口X username@hostname
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;好像很强，但有一个问题：之前使用固定的端口转发时，应用的访问请求都是指向被转发的那个端口 X 的，但现在应用的访问请求必须指向目标，以指定动态端口转发的目标。可如果不指向端口 X，如何让数据走 SSH 隧道呢？这就要求我们在系统或应用（浏览器等）中设置一个使用 SOCKS5 协议、服务器为 localhost、端口为 X 的代理，利用代理使请求走端口 X。&lt;/p&gt;
&lt;p&gt;这样应用的请求就从 X 进入隧道，抵达 B 后其中的目标信息被解析出来，B 访问目标后再将结果通过隧道返回给 A。比如在开启代理的 A 上的浏览器中访问 &lt;a href=&#34;http://zhihu.com&#34;&gt;http://zhihu.com&lt;/a&gt;，经过端口转发，相当于是 B 在帮 A 访问 &lt;a href=&#34;http://zhihu.com&#34;&gt;http://zhihu.com&lt;/a&gt;。&lt;/p&gt;
&lt;h2 id=&#34;五端口转发的停止&#34;&gt;五　端口转发的停止&lt;/h2&gt;
&lt;p&gt;SSH 端口转发完全基于基本的 SSH 连接，因此，通过在远程终端上执行 exit 命令、暴力关闭本地终端窗口、远程主机 B 关机、本地主机 A 关机等可以切断 SSH 连接的方式，即可停止 SSH 端口转发。就是这样。&lt;/p&gt;
- https://shenyiminghfut.github.io/posts/%E5%BD%BB%E5%BA%95%E6%90%9E%E6%87%82-ssh-%E7%AB%AF%E5%8F%A3%E8%BD%AC%E5%8F%91%E5%91%BD%E4%BB%A4/ - This is a customized copyright.</description>
        </item>
    
    
    
        <item>
        <title>中文文本测试</title>
        <link>https://shenyiminghfut.github.io/posts/chinese/</link>
        <pubDate>Thu, 14 Nov 2019 11:25:05 -0400</pubDate>
        
        <guid>https://shenyiminghfut.github.io/posts/chinese/</guid>
        <description>摆人日寄 https://shenyiminghfut.github.io/posts/chinese/ -&lt;p&gt;　　这样看来， 邓拓在不经意间这样说过，越是没有本领的就越加自命不凡。这不禁令我深思。 我们不得不面对一个非常尴尬的事实，那就是， 一般来说， 所谓中午吃什么，关键是中午吃什么需要如何写。 伏尔泰说过一句富有哲理的话，坚持意志伟大的事业需要始终不渝的精神。这启发了我， 那么， 对我个人而言，中午吃什么不仅仅是一个重大的事件，还可能会改变我的人生。 这样看来， 我们一般认为，抓住了问题的关键，其他一切则会迎刃而解。 一般来讲，我们都必须务必慎重的考虑考虑。 黑格尔说过一句富有哲理的话，只有永远躺在泥坑里的人，才不会再掉进坑里。这启发了我， 我们不得不面对一个非常尴尬的事实，那就是， 既然如何， 在这种困难的抉择下，本人思来想去，寝食难安。&lt;/p&gt;
&lt;p&gt;　　我认为， 而这些并不是完全重要，更加重要的问题是， 了解清楚中午吃什么到底是一种怎么样的存在，是解决一切问题的关键。 中午吃什么因何而发生？ 而这些并不是完全重要，更加重要的问题是， 卢梭在不经意间这样说过，浪费时间是一桩大罪过。这启发了我， 既然如此， 从这个角度来看， 歌德在不经意间这样说过，意志坚强的人能把世界放在手中像泥块一样任意揉捏。我希望诸位也能好好地体会这句话。 我认为， 我们一般认为，抓住了问题的关键，其他一切则会迎刃而解。 本人也是经过了深思熟虑，在每个日日夜夜思考这个问题。 这种事实对本人来说意义重大，相信对这个世界也是有一定意义的。 莎士比亚在不经意间这样说过，人的一生是短的，但如果卑劣地过这一生，就太长了。带着这句话，我们还要更加慎重的审视这个问题： 带着这些问题，我们来审视一下中午吃什么。 中午吃什么因何而发生？ 我们一般认为，抓住了问题的关键，其他一切则会迎刃而解。 布尔沃曾经说过，要掌握书，莫被书掌握；要为生而读，莫为读而生。这似乎解答了我的疑惑。 而这些并不是完全重要，更加重要的问题是， 生活中，若中午吃什么出现了，我们就不得不考虑它出现了的事实。 本人也是经过了深思熟虑，在每个日日夜夜思考这个问题。 带着这些问题，我们来审视一下中午吃什么。 生活中，若中午吃什么出现了，我们就不得不考虑它出现了的事实。 我认为， 一般来说， 中午吃什么，到底应该如何实现。 我们不得不面对一个非常尴尬的事实，那就是， 所谓中午吃什么，关键是中午吃什么需要如何写。 我们一般认为，抓住了问题的关键，其他一切则会迎刃而解。 现在，解决中午吃什么的问题，是非常非常重要的。　　我认为， 而这些并不是完全重要，更加重要的问题是， 了解清楚中午吃什么到底是一种怎么样的存在，是解决一切问题的关键。 中午吃什么因何而发生？ 而这些并不是完全重要，更加重要的问题是， 卢梭在不经意间这样说过，浪费时间是一桩大罪过。这启发了我， 既然如此， 从这个角度来看， 歌德在不经意间这样说过，意志坚强的人能把世界放在手中像泥块一样任意揉捏。我希望诸位也能好好地体会这句话。 我认为， 我们一般认为，抓住了问题的关键，其他一切则会迎刃而解。 本人也是经过了深思熟虑，在每个日日夜夜思考这个问题。 这种事实对本人来说意义重大，相信对这个世界也是有一定意义的。 莎士比亚在不经意间这样说过，人的一生是短的，但如果卑劣地过这一生，就太长了。带着这句话，我们还要更加慎重的审视这个问题： 带着这些问题，我们来审视一下中午吃什么。 中午吃什么因何而发生？ 我们一般认为，抓住了问题的关键，其他一切则会迎刃而解。 布尔沃曾经说过，要掌握书，莫被书掌握；要为生而读，莫为读而生。这似乎解答了我的疑惑。 而这些并不是完全重要，更加重要的问题是， 生活中，若中午吃什么出现了，我们就不得不考虑它出现了的事实。 本人也是经过了深思熟虑，在每个日日夜夜思考这个问题。 带着这些问题，我们来审视一下中午吃什么。 生活中，若中午吃什么出现了，我们就不得不考虑它出现了的事实。 我认为， 一般来说， 中午吃什么，到底应该如何实现。 我们不得不面对一个非常尴尬的事实，那就是， 所谓中午吃什么，关键是中午吃什么需要如何写。 我们一般认为，抓住了问题的关键，其他一切则会迎刃而解。 现在，解决中午吃什么的问题，是非常非常重要的。&lt;/p&gt;
&lt;p&gt;　　我们一般认为，抓住了问题的关键，其他一切则会迎刃而解。 可是，即使是这样，中午吃什么的出现仍然代表了一定的意义。 带着这些问题，我们来审视一下中午吃什么。 本人也是经过了深思熟虑，在每个日日夜夜思考这个问题。 我认为， 问题的关键究竟为何？ 非洲曾经提到过，最灵繁的人也看不见自己的背脊。这启发了我， 易卜生说过一句富有哲理的话，伟大的事业，需要决心，能力，组织和责任感。这似乎解答了我的疑惑。 一般来说， 在这种困难的抉择下，本人思来想去，寝食难安。 中午吃什么，到底应该如何实现。 经过上述讨论， 我们一般认为，抓住了问题的关键，其他一切则会迎刃而解。 中午吃什么因何而发生？
带着这些问题，我们来审视一下中午吃什么。 对我个人而言，中午吃什么不仅仅是一个重大的事件，还可能会改变我的人生。那就是， 一般来说， 所谓中午吃什么，关键是中午吃什么需要如何写。 伏尔泰说过一句富有哲理的话，坚持意志伟大的事业需要始终不渝的精神。这启发了我， 那么， 对我个人而言，中午吃什么不仅仅是一个重大的事件，还可能会改变我的人生。 这样看来， 我们一般认为，抓住了问题的关键，其他一切则会迎刃而解。 一般来讲，我们都必须务必慎重的考虑考虑。 黑格尔说过一句富有哲理的话，只有永远躺在泥坑里的人，才不会再掉进坑里。这启发了我， 我们不得不面对一个非常尴尬的事实，那就是， 既然如何， 在这种困难的抉择下，本人思来想去，寝食难安。&lt;/p&gt;
&lt;p&gt;　　我们一般认为，抓住了问题的关键，其他一切则会迎刃而解。 可是，即使是这样，中午吃什么的出现仍然代表了一定的意义。 带着这些问题，我们来审视一下中午吃什么。 本人也是经过了深思熟虑，在每个日日夜夜思考这个问题。 我认为， 问题的关键究竟为何？ 非洲曾经提到过，最灵繁的人也看不见自己的背脊。这启发了我， 易卜生说过一句富有哲理的话，伟大的事业，需要决心，能力，组织和责任感。这似乎解答了我的疑惑。 一般来说， 在这种困难的抉择下，本人思来想去，寝食难安。 中午吃什么，到底应该如何实现。 经过上述讨论， 我们一般认为，抓住了问题的关键，其他一切则会迎刃而解。 中午吃什么因何而发生？
带着这些问题，我们来审视一下中午吃什么。 对我个人而言，中午吃什么不仅仅是一个重大的事件，还可能会改变我的人生。&lt;/p&gt;
- https://shenyiminghfut.github.io/posts/chinese/ - This is a customized copyright.</description>
        </item>
    
    
    
        <item>
        <title>Git命令速查表</title>
        <link>https://shenyiminghfut.github.io/posts/git-%E5%91%BD%E4%BB%A4%E9%80%9F%E6%9F%A5/</link>
        <pubDate>Tue, 09 Apr 2019 10:58:08 -0400</pubDate>
        
        <guid>https://shenyiminghfut.github.io/posts/git-%E5%91%BD%E4%BB%A4%E9%80%9F%E6%9F%A5/</guid>
        <description>摆人日寄 https://shenyiminghfut.github.io/posts/git-%E5%91%BD%E4%BB%A4%E9%80%9F%E6%9F%A5/ -&lt;h2 id=&#34;创建命令&#34;&gt;创建命令&lt;/h2&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th width=&#34;35%&#34;&gt;Git 命令&lt;/th&gt;&lt;th&gt;说明&lt;/th&gt;&lt;/tr&gt;&lt;/thead&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;&lt;code&gt;git clone &amp;lt;url&amp;gt;&lt;/code&gt;&lt;/td&gt;&lt;td&gt;克隆远程仓库&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;code&gt;git init&lt;/code&gt;&lt;/td&gt;&lt;td&gt;初始化本地 git 仓库（即创建新的本地仓库）&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;
&lt;h2 id=&#34;本地更改&#34;&gt;本地更改&lt;/h2&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th width=&#34;35%&#34;&gt;Git 命令&lt;/th&gt;&lt;th&gt;说明&lt;/th&gt;&lt;/tr&gt;&lt;/thead&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;&lt;code&gt;git status&lt;/code&gt;&lt;/td&gt;&lt;td&gt;查看当前分支状态&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;code&gt;git diff&lt;/code&gt;&lt;/td&gt;&lt;td&gt;查看已跟踪文件的变更&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;code&gt;git add &amp;lt;file&amp;gt;&lt;/code&gt;&lt;/td&gt;&lt;td&gt;将指定的文件添加到暂存区&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;code&gt;git add .&lt;/code&gt;&lt;/td&gt;&lt;td&gt;将所有有变更的文件添加到暂存区&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;code&gt;git commit -a&lt;/code&gt;&lt;/td&gt;&lt;td&gt;提交所有本地修改&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;code&gt;git commit -m &#34;xxx&#34;&lt;/code&gt;&lt;/td&gt;&lt;td&gt;把已添加至暂存区的文件执行提交，并以 xxx 作为本次提交的描述&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;code&gt;git commit --amend -m &#34;xxx&#34;&lt;/code&gt;&lt;/td&gt;&lt;td&gt;修改上一次提交（请勿用该命令修改已发布的提交）&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;code&gt;git commit -am &#34;xxx&#34;&lt;/code&gt;&lt;/td&gt;&lt;td&gt;该命令是 &lt;code&gt;git add .&lt;/code&gt; 和 &lt;code&gt;git commit -m &#34;xxx&#34;&lt;/code&gt; 的快捷方式&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;code&gt;git stash&lt;/code&gt;&lt;/td&gt;&lt;td&gt;暂存当前修改，将所有置为 HEAD 状态&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;code&gt;git stash list&lt;/code&gt;&lt;/td&gt;&lt;td&gt;查看所有暂存列表&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;code&gt;git stash push&lt;/code&gt;&lt;/td&gt;&lt;td&gt;把当前工作区的文件暂存到临时空间&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;code&gt;git stash pop&lt;/code&gt;&lt;/td&gt;&lt;td&gt;把文件从临时空间中恢复到当前工作区&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;
&lt;h2 id=&#34;提交历史&#34;&gt;提交历史&lt;/h2&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th width=&#34;35%&#34;&gt;Git 命令&lt;/th&gt;&lt;th&gt;说明&lt;/th&gt;&lt;/tr&gt;&lt;/thead&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;&lt;code&gt;git log&lt;/code&gt;&lt;/td&gt;&lt;td&gt;查看提交日志&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;code&gt;git log -n&lt;/code&gt;&lt;/td&gt;&lt;td&gt;显示 n 行日志，n 为整数&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;code&gt;git log --stat&lt;/code&gt;&lt;/td&gt;&lt;td&gt;查看本地提交日志&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;code&gt;git show &amp;lt;commit&amp;gt;&lt;/code&gt;&lt;/td&gt;&lt;td&gt;查看提交日志及相关变动文件&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;code&gt;git show HEAD&lt;/code&gt;&lt;/td&gt;&lt;td&gt;查看 HEAD 提交日志&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;code&gt;git show HEAD^&lt;/code&gt;&lt;/td&gt;&lt;td&gt;查看 HEAD 的上一个版本提交日志。另外，&lt;code&gt;git show HEAD^^&lt;/code&gt; 是查看上 2 个版本的提交日志；&lt;code&gt;git show HEAD^5&lt;/code&gt; 是查看上 5 个版本的提交日志&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;code&gt;git blame &amp;lt;file&amp;gt;&lt;/code&gt;&lt;/td&gt;&lt;td&gt;对于指定文件，逐行显示提交的哈希 ID、提交者、提交日期以及修改的内容&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;code&gt;git whatchanged&lt;/code&gt;&lt;/td&gt;&lt;td&gt;显示提交历史，以及每次提交变更的文件&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;
&lt;h2 id=&#34;分支和标签&#34;&gt;分支和标签&lt;/h2&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th width=&#34;35%&#34;&gt;Git 命令&lt;/th&gt;&lt;th&gt;说明&lt;/th&gt;&lt;/tr&gt;&lt;/thead&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;&lt;code&gt;git branch&lt;/code&gt;&lt;/td&gt;&lt;td&gt;查看本地分支&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;code&gt;git branch -r&lt;/code&gt;&lt;/td&gt;&lt;td&gt;查看远程分支&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;code&gt;git branch -a&lt;/code&gt;&lt;/td&gt;&lt;td&gt;查看所有分支（本地和远程）&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;code&gt;git branch --merged&lt;/code&gt;&lt;/td&gt;&lt;td&gt;查看所有分支已合并到当前分支的分支&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;code&gt;git branch --no-merged&lt;/code&gt;&lt;/td&gt;&lt;td&gt;查看所有分支未合并到当前分支的分支&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;code&gt;git branch -m &amp;lt;new-branch&amp;gt;&lt;/code&gt;&lt;/td&gt;&lt;td&gt;把当前分支的名称改成 &lt;code&gt;new-branch&lt;/code&gt;；如果 &lt;code&gt;new-branch&lt;/code&gt; 已存在，将不会执行改名&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;code&gt;git branch -M &amp;lt;new-branch&amp;gt;&lt;/code&gt;&lt;/td&gt;&lt;td&gt;强制把当前分支的名称改成 &lt;code&gt;new-branch&lt;/code&gt;（即使 &lt;code&gt;new-branch&lt;/code&gt; 已存在）&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;code&gt;git branch -m &amp;lt;old-branch&amp;gt; &amp;lt;new-branch&amp;gt;&lt;/code&gt;&lt;/td&gt;&lt;td&gt;把分支 &lt;code&gt;old-branch&lt;/code&gt; 的名称改成 &lt;code&gt;new-branch&lt;/code&gt;，如果 &lt;code&gt;new-branch&lt;/code&gt; 已存在，将不会执行改名&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;code&gt;git branch -M &amp;lt;old-branch&amp;gt; &amp;lt;new-branch&amp;gt;&lt;/code&gt;&lt;/td&gt;&lt;td&gt;强制把分支 &lt;code&gt;old-branch&lt;/code&gt; 的名称改成 &lt;code&gt;new-branch&lt;/code&gt;（即使 &lt;code&gt;new-branch&lt;/code&gt; 已存在）&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;code&gt;git checkout &amp;lt;branch-name&amp;gt;&lt;/code&gt;&lt;/td&gt;&lt;td&gt;切换到 &lt;code&gt;branch-name&lt;/code&gt; 分支&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;code&gt;git branch &amp;lt;new-branch&amp;gt;&lt;/code&gt;&lt;/td&gt;&lt;td&gt;新建分支（也可以用 &lt;code&gt;git checkout -b &amp;lt;new-branch&amp;gt;&lt;/code&gt;）&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;code&gt;git branch --track &amp;lt;new&amp;gt; &amp;lt;remote&amp;gt;&lt;/code&gt;&lt;/td&gt;&lt;td&gt;基于远程分支创建一个新分支，同 &lt;code&gt;git checkout --track &amp;lt;remote/branch&amp;gt;&lt;/code&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;code&gt;git branch -d &amp;lt;branch-name&amp;gt;&lt;/code&gt;&lt;/td&gt;&lt;td&gt;删除本地分支&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;code&gt;git tag&lt;/code&gt;&lt;/td&gt;&lt;td&gt;列出所有本地标签&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;code&gt;git tag &amp;lt;tag-name&amp;gt;&lt;/code&gt;&lt;/td&gt;&lt;td&gt;基于最新的提交创建标签&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;code&gt;git tag -d &amp;lt;tag-name&amp;gt;&lt;/code&gt;&lt;/td&gt;&lt;td&gt;删除标签&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;
&lt;h2 id=&#34;删除命令&#34;&gt;删除命令&lt;/h2&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th width=&#34;35%&#34;&gt;Git 命令&lt;/th&gt;&lt;th&gt;说明&lt;/th&gt;&lt;/tr&gt;&lt;/thead&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;&lt;code&gt;git rm &amp;lt;file&amp;gt;&lt;/code&gt;&lt;/td&gt;&lt;td&gt;删除文件（将从磁盘中删除文件）&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;code&gt;git rm -r &amp;lt;directory&amp;gt;&lt;/code&gt;&lt;/td&gt;&lt;td&gt;递归删除指定目录下的文件&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;code&gt;git rm --cached &amp;lt;file&amp;gt;&lt;/code&gt;&lt;/td&gt;&lt;td&gt;停止跟踪文件，不会从磁盘中删除&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;
&lt;h2 id=&#34;合并和衍合&#34;&gt;合并和衍合&lt;/h2&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th width=&#34;35%&#34;&gt;Git 命令&lt;/th&gt;&lt;th&gt;说明&lt;/th&gt;&lt;/tr&gt;&lt;/thead&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;&lt;code&gt;git merge &amp;lt;branch&amp;gt;&lt;/code&gt;&lt;/td&gt;&lt;td&gt;合并指定分支到当前分支，保留两个&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;code&gt;git rebase &amp;lt;branch&amp;gt;&lt;/code&gt;&lt;/td&gt;&lt;td&gt;合并指定分支到当前分支，只保留一个&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;code&gt;git rebase --abort&lt;/code&gt;&lt;/td&gt;&lt;td&gt;终止 rebase 操作，即回到执行 rebase 之前的状态&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;code&gt;git rebase --continue&lt;/code&gt;&lt;/td&gt;&lt;td&gt;解决冲突后继续执行 rebase&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;code&gt;git mergetool&lt;/code&gt;&lt;/td&gt;&lt;td&gt;使用配置文件指定的 mergetool 解决冲突&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;code&gt;git add &amp;lt;resolved-file&amp;gt;&lt;/code&gt;&lt;br&gt;&lt;code&gt;git rm &amp;lt;resolved-file&amp;gt;&lt;/code&gt;&lt;br&gt;&lt;/td&gt;&lt;td&gt;使用编辑器手动解决文件冲突，并在冲突解决后，把文件标记为 resolved&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;
&lt;h2 id=&#34;撤销命令&#34;&gt;撤销命令&lt;/h2&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th width=&#34;35%&#34;&gt;Git 命令&lt;/th&gt;&lt;th&gt;说明&lt;/th&gt;&lt;/tr&gt;&lt;/thead&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;&lt;code&gt;git reset --hard HEAD&lt;/code&gt;&lt;/td&gt;&lt;td&gt;将当前版本重置为 HEAD（用于 merge 失败的时候）&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;code&gt;git reset &amp;lt;commit&amp;gt;&lt;/code&gt;&lt;/td&gt;&lt;td&gt;将当前版本重置为某一个提交状态，代码不变&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;code&gt;git reset --hard &amp;lt;commit&amp;gt;&lt;/code&gt;&lt;/td&gt;&lt;td&gt;强制将当前版本重置为某一个提交状态，并丢弃那个状态之后的所有修改（请谨慎使用该命令）&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;code&gt;git reset --merge &amp;lt;commit&amp;gt;&lt;/code&gt;&lt;/td&gt;&lt;td&gt;将当前版本重置为某一个提交状态，并保留版本库中不同的文件&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;code&gt;git reset --keep &amp;lt;commit&amp;gt;&lt;/code&gt;&lt;/td&gt;&lt;td&gt;将当前版本重置为某一个提交状态，并保留未提交的本地修改&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;code&gt;git revert &amp;lt;commit&amp;gt;&lt;/code&gt;&lt;/td&gt;&lt;td&gt;撤销提交&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;code&gt;git restore &amp;lt;file&amp;gt;&lt;/code&gt;&lt;/td&gt;&lt;td&gt;丢弃指定文件的修改信息，即恢复到文件修改前的状态&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;code&gt;git checkout -- &amp;lt;file&amp;gt;&lt;/code&gt;&lt;/td&gt;&lt;td&gt;同 &lt;code&gt;git restore &amp;lt;file&amp;gt;&lt;/code&gt; 命令&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;code&gt;git checkout HEAD &amp;lt;file&amp;gt;&lt;/code&gt;&lt;/td&gt;&lt;td&gt;对于指定文件，丢弃该文件的本地修改信息&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;code&gt;git clean&lt;/code&gt;&lt;/td&gt;&lt;td&gt;清除工作目录中未跟踪的文件&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;code&gt;git clean -n&lt;/code&gt;&lt;/td&gt;&lt;td&gt;列出哪些文件将从工作目录中删除&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;
&lt;h2 id=&#34;配置命令&#34;&gt;配置命令&lt;/h2&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th width=&#34;35%&#34;&gt;Git 命令&lt;/th&gt;&lt;th&gt;说明&lt;/th&gt;&lt;/tr&gt;&lt;/thead&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;&lt;code&gt;git config --list&lt;/code&gt;&lt;/td&gt;&lt;td&gt;列出当前 Git 配置&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;code&gt;git config --global user.name &amp;lt;name&amp;gt;&lt;/code&gt;&lt;/td&gt;&lt;td&gt;把参数 &lt;code&gt;name&lt;/code&gt; 设置为当前用户使用的提交者的姓名；如果未指定 &lt;code&gt;name&lt;/code&gt; 参数，则显示当前用户使用的提交者姓名&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;code&gt;git config --global user.email &amp;lt;email&amp;gt;&lt;/code&gt;&lt;/td&gt;&lt;td&gt;把参数 &lt;code&gt;email&lt;/code&gt; 设置为当前用户使用的提交者的邮箱；如果未指定 &lt;code&gt;email&lt;/code&gt; 参数，则显示当前用户使用的提交者邮箱&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;code&gt;git config --global alias.&amp;lt;alias&amp;gt; &amp;lt;command&amp;gt;&lt;/code&gt;&lt;/td&gt;&lt;td&gt;为 Git 命令创建全局的别名。比如，执行 &lt;code&gt;alias.glog log --graph --oneline --decorate&lt;/code&gt; 命令后，&lt;code&gt;git glog&lt;/code&gt; 就相当于 &lt;code&gt;git log --graph --oneline --decorate&lt;/code&gt;。&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;code&gt;git config --system core.editor &amp;lt;editor&amp;gt;&lt;/code&gt;&lt;/td&gt;&lt;td&gt;对于本机的所有用户，设置命令使用的编辑器（比如 &lt;code&gt;vim&lt;/code&gt;）&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;code&gt;git config --global --edit&lt;/code&gt;&lt;/td&gt;&lt;td&gt;在编辑器中打开全局配置文件（用于手动修改）&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;code&gt;git config --global color.ui auto&lt;/code&gt;&lt;/td&gt;&lt;td&gt;使用不同的颜色渲染 Git 命令的输出结果&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;
&lt;h2 id=&#34;其他命令&#34;&gt;其他命令&lt;/h2&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th width=&#34;35%&#34;&gt;Git 命令&lt;/th&gt;&lt;th&gt;说明&lt;/th&gt;&lt;/tr&gt;&lt;/thead&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;&lt;code&gt;git var -l&lt;/code&gt;&lt;/td&gt;&lt;td&gt;列出 Git 环境变量&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;code&gt;git help &amp;lt;command&amp;gt;&lt;/code&gt;&lt;/td&gt;&lt;td&gt;显示指定命令的帮助（将呼出该命令的 man 文件）&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;
- https://shenyiminghfut.github.io/posts/git-%E5%91%BD%E4%BB%A4%E9%80%9F%E6%9F%A5/ - This is a customized copyright.</description>
        </item>
    
    
    
    
  </channel>
</rss> 